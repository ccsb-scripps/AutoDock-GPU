// OCLADock: AUTOMATICALLY GENERATED FILE, DO NOT EDIT.
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *calcenergy_ocl =
"/*\n"
"\n"
"AutoDock-GPU, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"For some of the code, Copyright (C) 2019 Computational Structural Biology Center, the Scripps Research Institute.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This library is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU Lesser General Public\n"
"License as published by the Free Software Foundation; either\n"
"version 2.1 of the License, or (at your option) any later version.\n"
"\n"
"This library is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"Lesser General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU Lesser General Public\n"
"License along with this library; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n"
"\n"
"*/\n"
"\n"
"\n"
"#ifndef DEFINES_H_\n"
"#define DEFINES_H_\n"
"\n"
"#if defined (N1WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 1\n"
"#elif defined (N2WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 2\n"
"#elif defined (N4WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 4\n"
"#elif defined (N8WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 8\n"
"#elif defined (N16WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 16\n"
"#elif defined (N32WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 32\n"
"#elif defined (N64WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 64\n"
"#elif defined (N128WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 128\n"
"#elif defined (N256WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 256\n"
"#else\n"
"	#define NUM_OF_THREADS_PER_BLOCK 16\n"
"#endif\n"
"\n"
"typedef enum\n"
"{\n"
"	idx_000 = 0,\n"
"	idx_010 = 1,\n"
"	idx_001 = 2,\n"
"	idx_011 = 3,\n"
"	idx_100 = 4,\n"
"	idx_110 = 5,\n"
"	idx_101 = 6,\n"
"	idx_111 = 7\n"
"} indices;\n"
"\n"
"enum {C=0,N=1,O=2,H=3,XX=4,P=5,S=6};  // see \"bond_index\" in the \"AD4.1_bound.dat\" or \"AD4_parameters.dat\" file.\n"
"#define NUM_ENUM_ATOMTYPES 7 // this should be the length of the enumerated atom types above\n"
"\n"
"// Indexes of atomic types used in\n"
"// host/src/processligand.cpp/get_VWpars(),\n"
"// and kernel energy & gradient calculation.\n"
"#define ATYPE_NUM                  30 // 22 (initial + Si + B) + 2 (CG & G0 for handling flexrings) + W (waters) + CX + NX + OX\n"
"\n"
"#define ATYPE_CG_IDX               24\n"
"#define ATYPE_G0_IDX               25\n"
"#define ATYPE_W_IDX                26\n"
"#define ATYPE_CX_IDX               27\n"
"#define ATYPE_NX_IDX               28\n"
"#define ATYPE_OX_IDX               29\n"
"\n"
"// Indexes of atomic types used in\n"
"// host/src/processligand.cpp/get_bonds().\n"
"// Added definition to support flexrings.\n"
"#define ATYPE_GETBONDS             22 // + CX [ Nx / Ox already accounted for ] + Si + B\n"
"\n"
"#define MAX_NUM_OF_ATOMS           256\n"
"#define MAX_NUM_OF_ATYPES          32\n"
"// 57+6 (+1 for eventual angle in axisangle representation) = 63 or 64\n"
"#define MAX_NUM_OF_ROTBONDS        57\n"
"#define MAX_INTRAE_CONTRIBUTORS    (MAX_NUM_OF_ATOMS * MAX_NUM_OF_ATOMS)\n"
"#define MAX_NUM_OF_ROTATIONS       (MAX_NUM_OF_ATOMS * MAX_NUM_OF_ROTBONDS)\n"
"#define MAX_POPSIZE                2048\n"
"#define MAX_NUM_OF_RUNS            8192\n"
"#define MAX_NUM_GRIDPOINTS         256\n"
"\n"
"// Must be larger than or equal to MAX_NUM_OF_ROTBONDS+6\n"
"#define GENOTYPE_LENGTH_IN_GLOBMEM 64\n"
"#define ACTUAL_GENOTYPE_LENGTH     (MAX_NUM_OF_ROTBONDS+6)\n"
"\n"
"#define LS_EXP_FACTOR              2.0f\n"
"#define LS_CONT_FACTOR             0.5f\n"
"\n"
"// Improvements over Pechan's implementation\n"
"#define MAPPED_COPY\n"
"\n"
"\n"
"// Coefficients for CG-G0 pairs used in\n"
"// host/src/processligand.cpp/calc_intraE_f(),\n"
"// and in kernel energy and gradient calculation.\n"
"// Added definition to support flexrings.\n"
"#define G 50.0f\n"
"\n"
"// Enables full floating point gradient calculation.\n"
"// Use is not advised as:\n"
"// - the determinism gradients (aka integer gradients) are much faster *and*\n"
"// - speed up the local search convergence\n"
"// Please only use for debugging\n"
"// #define FLOAT_GRADIENTS\n"
"\n"
"// Use one more coefficient in the fit to the Mehler-Solmajer dielectric in energrad implementation\n"
"// Although this improves the fit (particularly for the gradient), it costs a little bit more and\n"
"// does not return better accuracy overall (default: commented out, don't use)\n"
"// #define DIEL_FIT_ABC\n"
"\n"
"// Output for the -derivtype keyword\n"
"// #define DERIVTYPE_INFO\n"
"\n"
"// Output for the -modpair keyword\n"
"// #define MODPAIR_INFO\n"
"\n"
"#endif /* DEFINES_H_ */\n"
"/*\n"
"\n"
"AutoDock-GPU, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"For some of the code, Copyright (C) 2019 Computational Structural Biology Center, the Scripps Research Institute.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This library is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU Lesser General Public\n"
"License as published by the Free Software Foundation; either\n"
"version 2.1 of the License, or (at your option) any later version.\n"
"\n"
"This library is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"Lesser General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU Lesser General Public\n"
"License along with this library; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n"
"\n"
"*/\n"
"\n"
"\n"
"#ifndef CALCENERGY_BASIC_H_\n"
"#define CALCENERGY_BASIC_H_\n"
"\n"
"\n"
"#define RLIST_ATOMID_MASK       0x000000FF\n"
"#define RLIST_RBONDID_MASK      0x0000FF00\n"
"#define RLIST_RBONDID_SHIFT     8\n"
"#define RLIST_FIRSTROT_MASK     0x00010000\n"
"#define RLIST_GENROT_MASK       0x00020000\n"
"#define RLIST_DUMMY_MASK        0x00040000\n"
"\n"
"#define DEG_TO_RAD              0.0174533f\n"
"\n"
"// LCG: linear congruential generator constants\n"
"#define RAND_A                  1103515245u\n"
"#define RAND_C                  12345u\n"
"// WARNING: it is supposed that unsigned int is 32 bit long\n"
"#define MAX_UINT                4294967296.0f\n"
"\n"
"// Sticking to array boundaries\n"
"#define stick_to_bounds(x,a,b) x + (x <= a)*(a-x) + (x >= b)*(b-x)\n"
"\n"
"// e^2/4pie0 in kcal/mol\n"
"#define ELEC_SCALE_FACTOR        332.06363f\n"
"\n"
"// Constants for dielelectric term of the\n"
"// electrostatic component of the intramolecular energy/gradient\n"
"#define DIEL_A                   -8.5525f\n"
"#define DIEL_WAT                 78.4f\n"
"#define DIEL_B                   (DIEL_WAT - DIEL_A)\n"
"#define DIEL_LAMBDA              0.003627f\n"
"#define DIEL_H                   DIEL_LAMBDA\n"
"#define DIEL_K                   7.7839f\n"
"#define DIEL_B_TIMES_H           (DIEL_B * DIEL_H)\n"
"#define DIEL_B_TIMES_H_TIMES_K   (DIEL_B_TIMES_H * DIEL_K)\n"
"\n"
"// Used for Shoemake to quaternion transformation\n"
"#if defined(M_PI)\n"
"	#define PI_FLOAT (float)(M_PI)\n"
"#else\n"
"	#define PI_FLOAT 3.14159265359f\n"
"#endif\n"
"#define PI_TIMES_2       (2.0f*PI_FLOAT)\n"
"#define PI_HALF          (0.5f*PI_FLOAT)\n"
"\n"
"// -------------------------------------------\n"
"// Gradient-related defines\n"
"// -------------------------------------------\n"
"\n"
"#define INFINITESIMAL_RADIAN            1E-3f\n"
"#define HALF_INFINITESIMAL_RADIAN       (float)(0.5f * INFINITESIMAL_RADIAN)\n"
"#define INV_INFINITESIMAL_RADIAN        (1.0f/INFINITESIMAL_RADIAN)\n"
"#define COS_HALF_INFINITESIMAL_RADIAN   cos(HALF_INFINITESIMAL_RADIAN)\n"
"#define SIN_HALF_INFINITESIMAL_RADIAN   sin(HALF_INFINITESIMAL_RADIAN)\n"
"#define inv_angle_delta                 (500.0f / PI_FLOAT)\n"
"\n"
"/*\n"
"#define TRANGENE_ALPHA 1E-3\n"
"#define ROTAGENE_ALPHA 1E-8\n"
"#define TORSGENE_ALPHA 1E-13\n"
"*/\n"
"\n"
"#define STEP_INCREASE           1.2f\n"
"#define STEP_DECREASE           0.2f\n"
"#define STEP_START              1000.0f         // Starting step size. This might look gigantic but will cap\n"
"#define MAX_DEV_TRANSLATION     2.0f            // 2 Angstrom, but must be divided by the gridspacing (store in variable)\n"
"//#define MAX_DEV_ROTATION      0.2f            // Shoemake range [0, 1]\n"
"#define MAX_DEV_ROTATION        0.5f/DEG_TO_RAD // 0.5f RAD\n"
"#define MAX_DEV_TORSION         0.5f/DEG_TO_RAD // 0.5f RAD\n"
"\n"
"\n"
"#endif /* CALCENERGY_BASIC_H_ */\n"
"/*\n"
"\n"
"AutoDock-GPU, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"For some of the code, Copyright (C) 2019 Computational Structural Biology Center, the Scripps Research Institute.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This library is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU Lesser General Public\n"
"License as published by the Free Software Foundation; either\n"
"version 2.1 of the License, or (at your option) any later version.\n"
"\n"
"This library is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"Lesser General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU Lesser General Public\n"
"License along with this library; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n"
"\n"
"*/\n"
"\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"uint gpu_rand(__global uint* restrict prng_states)\n"
"// The GPU device function generates a random int\n"
"// with a linear congruential generator.\n"
"// Each thread (supposing num_of_runs*pop_size blocks and NUM_OF_THREADS_PER_BLOCK threads per block)\n"
"// has its own state which is stored in the global memory area pointed by\n"
"// prng_states (thread with ID tx in block with ID bx stores its state in prng_states[bx*NUM_OF_THREADS_PER_BLOCK+$\n"
"// The random number generator uses the gcc linear congruential generator constants.\n"
"{\n"
"	uint state;\n"
"\n"
"	// Current state of the threads own PRNG\n"
"	// state = prng_states[get_group_id(0)*NUM_OF_THREADS_PER_BLOCK + get_local_id(0)];\n"
"	state = prng_states[get_global_id(0)];\n"
"\n"
"	// Calculating next state\n"
"	state = (RAND_A*state+RAND_C);\n"
"\n"
"	// Saving next state to memory\n"
"	// prng_states[get_group_id(0)*NUM_OF_THREADS_PER_BLOCK + get_local_id(0)] = state;\n"
"	prng_states[get_global_id(0)] = state;\n"
"\n"
"  return state;\n"
"}\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"float gpu_randf(__global uint* restrict prng_states)\n"
"// The GPU device function generates a\n"
"// random float greater than (or equal to) 0 and less than 1.\n"
"// It uses gpu_rand() function.\n"
"{\n"
"	float state;\n"
"\n"
"	// State will be between 0 and 1\n"
"	state =  native_divide(gpu_rand(prng_states),MAX_UINT)*0.999999f;\n"
"\n"
"	return state;\n"
"}\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"void map_angle(__local float* angle)\n"
"// The GPU device function maps\n"
"// the input parameter to the interval 0...360\n"
"// (supposing that it is an angle).\n"
"{\n"
"	while (*angle >= 360.0f) {\n"
"		*angle -= 360.0f;\n"
"	}\n"
"\n"
"	while (*angle < 0.0f) {\n"
"		*angle += 360.0f;\n"
"	}\n"
"}\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"void gpu_perform_elitist_selection(\n"
"                                            int    dockpars_pop_size,\n"
"                                   __global float* restrict dockpars_energies_current,\n"
"                                   __global float* restrict dockpars_energies_next,\n"
"                                   __global int*   restrict dockpars_evals_of_new_entities,\n"
"                                            int    dockpars_num_of_genes,\n"
"                                   __global float* restrict dockpars_conformations_next,\n"
"                             __global const float* restrict dockpars_conformations_current,\n"
"                                   __local  float* best_energies,\n"
"                                   __local  int*   best_IDs,\n"
"                                   __local  int*   best_ID\n"
"                                  )\n"
"// The GPU device function performs elitist selection,\n"
"// that is, it looks for the best entity in conformations_current and\n"
"// energies_current of the run that corresponds to the block ID,\n"
"// and copies it to the place of the first entity in\n"
"// conformations_next and energies_next.\n"
"{\n"
"	int entity_counter;\n"
"	int gene_counter;\n"
"	float best_energy;\n"
"	int tidx = get_local_id(0);\n"
"\n"
"	if (tidx < dockpars_pop_size) {\n"
"		best_energies[tidx] = dockpars_energies_current[get_group_id(0)+tidx];\n"
"		best_IDs[tidx] = tidx;\n"
"	}\n"
"\n"
"	for (entity_counter = NUM_OF_THREADS_PER_BLOCK+tidx;\n"
"	     entity_counter < dockpars_pop_size;\n"
"	     entity_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		if (dockpars_energies_current[get_group_id(0)+entity_counter] < best_energies[tidx]) {\n"
"			best_energies[tidx] = dockpars_energies_current[get_group_id(0)+entity_counter];\n"
"			best_IDs[tidx] = entity_counter;\n"
"		}\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// This could be implemented with a tree-like structure\n"
"	// which may be slightly faster\n"
"	if (tidx == 0)\n"
"	{\n"
"		best_energy = best_energies[0];\n"
"		best_ID[0] = best_IDs[0];\n"
"\n"
"		for (entity_counter = 1;\n"
"		     entity_counter < NUM_OF_THREADS_PER_BLOCK;\n"
"		     entity_counter++)\n"
"		{\n"
"			if ((best_energies[entity_counter] < best_energy) && (entity_counter < dockpars_pop_size)) {\n"
"				best_energy = best_energies[entity_counter];\n"
"				best_ID[0] = best_IDs[entity_counter];\n"
"			}\n"
"		}\n"
"\n"
"		// Setting energy value of new entity\n"
"		dockpars_energies_next[get_group_id(0)] = best_energy;\n"
"\n"
"		// Zero (0) evals were performed for entity selected with elitism (since it was copied only)\n"
"		dockpars_evals_of_new_entities[get_group_id(0)] = 0;\n"
"	}\n"
"	// \"best_id\" stores the id of the best entity in the population,\n"
"	// Copying genotype and energy value to the first entity of new population\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	for (gene_counter = tidx;\n"
"	     gene_counter < dockpars_num_of_genes;\n"
"	     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		dockpars_conformations_next[GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0)+gene_counter] = dockpars_conformations_current[GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0) + GENOTYPE_LENGTH_IN_GLOBMEM*best_ID[0]+gene_counter];\n"
"	}\n"
"}\n"
"/*\n"
"\n"
"AutoDock-GPU, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"For some of the code, Copyright (C) 2019 Computational Structural Biology Center, the Scripps Research Institute.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This library is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU Lesser General Public\n"
"License as published by the Free Software Foundation; either\n"
"version 2.1 of the License, or (at your option) any later version.\n"
"\n"
"This library is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"Lesser General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU Lesser General Public\n"
"License along with this library; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n"
"\n"
"*/\n"
"\n"
"\n"
"//#define DEBUG_ENERGY_KERNEL\n"
"\n"
"// No needed to be included as all kernel sources are stringified\n"
"#if 0\n"
"#endif\n"
"\n"
"typedef struct\n"
"{\n"
"	float atom_charges_const  [MAX_NUM_OF_ATOMS];\n"
"	int   atom_types_const    [MAX_NUM_OF_ATOMS];\n"
"	int   atom_types_map_const[MAX_NUM_OF_ATOMS];\n"
"	char  ignore_inter_const  [MAX_NUM_OF_ATOMS];\n"
"} kernelconstant_interintra;\n"
"\n"
"typedef struct\n"
"{\n"
"	int intraE_contributors_const[2*MAX_INTRAE_CONTRIBUTORS];\n"
"} kernelconstant_intracontrib;\n"
"\n"
"typedef struct\n"
"{\n"
"	unsigned int       atom_types_reqm_const[MAX_NUM_OF_ATYPES];\n"
"	unsigned short int VWpars_exp_const     [MAX_NUM_OF_ATYPES*MAX_NUM_OF_ATYPES];\n"
"	float              reqm_AB_const        [MAX_NUM_OF_ATYPES*MAX_NUM_OF_ATYPES];\n"
"	float              VWpars_AC_const      [MAX_NUM_OF_ATYPES*MAX_NUM_OF_ATYPES];\n"
"	float              VWpars_BD_const      [MAX_NUM_OF_ATYPES*MAX_NUM_OF_ATYPES];\n"
"	float              dspars_S_const       [MAX_NUM_OF_ATYPES];\n"
"	float              dspars_V_const       [MAX_NUM_OF_ATYPES];\n"
"} kernelconstant_intra;\n"
"\n"
"typedef struct\n"
"{\n"
"	int rotlist_const     [MAX_NUM_OF_ROTATIONS];\n"
"} kernelconstant_rotlist;\n"
"\n"
"typedef struct\n"
"{\n"
"	float ref_coords_const             [3*MAX_NUM_OF_ATOMS];\n"
"	float rotbonds_moving_vectors_const[3*MAX_NUM_OF_ROTBONDS];\n"
"	float rotbonds_unit_vectors_const  [3*MAX_NUM_OF_ROTBONDS];\n"
"} kernelconstant_conform;\n"
"\n"
"// Magic positive integer exponent power ... -AT\n"
"// - it's in here mostly for testing/optimizing Cuda performance:\n"
"// - OpenCL's native_pwr(float, uint) is about 15%-20% faster, ...\n"
"// - but Cuda's floating point power isn't optimized for positive integers so it's much slower\n"
"inline float positive_power(float a, uint exp)\n"
"{\n"
"	// example a = 1.4, exp = 7\n"
"	float result=(exp & 1)?a:1.0f; // result = 1.4\n"
"	while(exp>>=1){ // [1] (exp>>=1) = true; exp -> 3 [2] true, exp -> 1 [3] false\n"
"		a *= a; // [1] a = 1.4^2 [2] a = 1.4^4\n"
"		result=(exp & 1)?result*a:result; // [1] result = 1.4^3 [2] result = 1.4^7\n"
"	}\n"
"	\n"
"	return result;\n"
"}\n"
"\n"
"#define invpi2 1.0f/(PI_TIMES_2)\n"
"\n"
"inline float fmod_pi2(float x)\n"
"{\n"
"	return x-((int)(invpi2*x))*PI_TIMES_2;\n"
"}\n"
"\n"
"#define fast_acos_a  9.78056e-05f\n"
"#define fast_acos_b -0.00104588f\n"
"#define fast_acos_c  0.00418716f\n"
"#define fast_acos_d -0.00314347f\n"
"#define fast_acos_e  2.74084f\n"
"#define fast_acos_f  0.370388f\n"
"#define fast_acos_o -(fast_acos_a+fast_acos_b+fast_acos_c+fast_acos_d)\n"
"\n"
"inline float fast_acos(float cosine)\n"
"{\n"
"	float x=fabs(cosine);\n"
"	float x2=x*x;\n"
"	float x3=x2*x;\n"
"	float x4=x3*x;\n"
"	float ac=(((fast_acos_o*x4+fast_acos_a)*x3+fast_acos_b)*x2+fast_acos_c)*x+fast_acos_d+\n"
"		 fast_acos_e*native_sqrt(2.0f-native_sqrt(2.0f+2.0f*x))-fast_acos_f*native_sqrt(2.0f-2.0f*x);\n"
"	return copysign(ac,cosine) + (cosine<0.0f)*PI_FLOAT;\n"
"}\n"
"\n"
"inline float4 quaternion_multiply(float4 a, float4 b)\n"
"{\n"
"	float4 result = { a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y, // x\n"
"			  a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x, // y\n"
"			  a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w, // z\n"
"			  a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z }; // w\n"
"	return result;\n"
"}\n"
"\n"
"inline float4 quaternion_rotate(float4 v, float4 rot)\n"
"{\n"
"	float4 result;\n"
"	\n"
"	float4 z=cross(rot,v) * 2.0f;\n"
"	result = v + z*rot.w + cross(rot,z);\n"
"	\n"
"	return result;\n"
"}\n"
"\n"
"// All related pragmas are in defines.h (accesible by host and device code)\n"
"\n"
"void gpu_calc_energy(\n"
"                           int     dockpars_rotbondlist_length,\n"
"                           int     dockpars_num_of_atoms,\n"
"                           int     dockpars_true_ligand_atoms,\n"
"                           int     dockpars_gridsize_x,\n"
"                           int     dockpars_gridsize_y,\n"
"                           int     dockpars_gridsize_z,\n"
"                                                                        // g1 = gridsize_x\n"
"                           uint    dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"                           uint    dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"            __global const float*  restrict dockpars_fgrids, // This is too large to be allocated in __constant\n"
"                           int     dockpars_num_of_atypes,\n"
"                           int     dockpars_num_of_map_atypes,\n"
"                           int     dockpars_num_of_intraE_contributors,\n"
"                           float   dockpars_grid_spacing,\n"
"                           float   dockpars_coeff_elec,\n"
"                           float   dockpars_elec_min_distance,\n"
"                           float   dockpars_qasp,\n"
"                           float   dockpars_coeff_desolv,\n"
"                           float   dockpars_smooth,\n"
"\n"
"                           // Some OpenCL compilers don't allow declaring\n"
"                           // local variables within non-kernel functions.\n"
"                           // These local variables must be declared in a kernel,\n"
"                           // and then passed to non-kernel functions.\n"
"                   __local float*  genotype,\n"
"                   __local float*  energy,\n"
"                   __local int*    run_id,\n"
"\n"
"                   __local float4* calc_coords,\n"
"                   __local float*  partial_energies,\n"
"\n"
"            #if defined (DEBUG_ENERGY_KERNEL)\n"
"                   __local float*  partial_interE,\n"
"                   __local float*  partial_intraE,\n"
"            #endif\n"
"#if 0\n"
"                           bool    debug,\n"
"#endif\n"
"          __constant       kernelconstant_interintra*   kerconst_interintra,\n"
"            __global const kernelconstant_intracontrib* kerconst_intracontrib,\n"
"          __constant       kernelconstant_intra*        kerconst_intra,\n"
"          __constant       kernelconstant_rotlist*      kerconst_rotlist,\n"
"          __constant       kernelconstant_conform*      kerconst_conform\n"
"                    )\n"
"// The GPU device function calculates the energy of the entity described by genotype, dockpars and the liganddata\n"
"// arrays in constant memory and returns it in the energy parameter. The parameter run_id has to be equal to the ID\n"
"// of the run whose population includes the current entity (which can be determined with blockIdx.x), since this\n"
"// determines which reference orientation should be used.\n"
"{\n"
"	int tidx = get_local_id(0);\n"
"	partial_energies[tidx] = 0.0f;\n"
"\n"
"	#if defined (DEBUG_ENERGY_KERNEL)\n"
"	partial_interE[tidx] = 0.0f;\n"
"	partial_intraE[tidx] = 0.0f;\n"
"	#endif\n"
"\n"
"	// Initializing gradients (forces) \n"
"	// Derived from autodockdev/maps.py\n"
"	for ( int atom_id = tidx;\n"
"	          atom_id < dockpars_num_of_atoms;\n"
"	          atom_id+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		// Initialize coordinates\n"
"		calc_coords[atom_id] = (float4)(kerconst_conform->ref_coords_const[3*atom_id],\n"
"		                                kerconst_conform->ref_coords_const[3*atom_id+1],\n"
"		                                kerconst_conform->ref_coords_const[3*atom_id+2],0);\n"
"	}\n"
"\n"
"	// General rotation moving vector\n"
"	float4 genrot_movingvec;\n"
"	// Convert orientation genes from sex. to radians\n"
"	float phi         = genotype[3] * DEG_TO_RAD;\n"
"	float theta       = genotype[4] * DEG_TO_RAD;\n"
"	float genrotangle = genotype[5] * DEG_TO_RAD;\n"
"\n"
"	float4 genrot_unitvec;\n"
"	if(dockpars_true_ligand_atoms){\n"
"		genrot_movingvec.x = genotype[0];\n"
"		genrot_movingvec.y = genotype[1];\n"
"		genrot_movingvec.z = genotype[2];\n"
"		genrot_movingvec.w = 0.0f;\n"
"		float sin_angle = native_sin(theta);\n"
"		float s2 = native_sin(genrotangle*0.5f);\n"
"		genrot_unitvec.x = s2*sin_angle*native_cos(phi);\n"
"		genrot_unitvec.y = s2*sin_angle*native_sin(phi);\n"
"		genrot_unitvec.z = s2*native_cos(theta);\n"
"		genrot_unitvec.w = native_cos(genrotangle*0.5f);\n"
"	}\n"
"\n"
"	uint g1 = dockpars_gridsize_x;\n"
"	uint g2 = dockpars_gridsize_x_times_y;\n"
"	uint g3 = dockpars_gridsize_x_times_y_times_z;\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// ================================================\n"
"	// CALCULATING ATOMIC POSITIONS AFTER ROTATIONS\n"
"	// ================================================\n"
"	for ( int rotation_counter = tidx;\n"
"	          rotation_counter < dockpars_rotbondlist_length;\n"
"	          rotation_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		int rotation_list_element = kerconst_rotlist->rotlist_const[rotation_counter];\n"
"		if ((rotation_list_element & RLIST_DUMMY_MASK) == 0) // If not dummy rotation\n"
"		{\n"
"			int atom_id = rotation_list_element & RLIST_ATOMID_MASK;\n"
"			// Capturing atom coordinates\n"
"			float4 atom_to_rotate = calc_coords[atom_id];\n"
"			// initialize with general rotation values\n"
"			float4 rotation_unitvec;\n"
"			float4 rotation_movingvec;\n"
"			if (atom_id < dockpars_true_ligand_atoms){\n"
"				rotation_unitvec = genrot_unitvec;\n"
"				rotation_movingvec = genrot_movingvec;\n"
"			} else{\n"
"				rotation_unitvec.x = 0.0f; rotation_unitvec.y = 0.0f; rotation_unitvec.z = 0.0f;\n"
"				rotation_unitvec.w = 1.0f;\n"
"				rotation_movingvec.x = 0.0f; rotation_movingvec.y = 0.0f; rotation_movingvec.z = 0.0f;\n"
"				rotation_movingvec.w = 0.0f;\n"
"			}\n"
"\n"
"			if ((rotation_list_element & RLIST_GENROT_MASK) == 0) // If rotating around rotatable bond\n"
"			{\n"
"				uint rotbond_id = (rotation_list_element & RLIST_RBONDID_MASK) >> RLIST_RBONDID_SHIFT;\n"
"				float rotation_angle = genotype[6+rotbond_id]*DEG_TO_RAD*0.5f;\n"
"				float s = native_sin(rotation_angle);\n"
"				rotation_unitvec = (float4)(s*kerconst_conform->rotbonds_unit_vectors_const[3*rotbond_id],\n"
"				                            s*kerconst_conform->rotbonds_unit_vectors_const[3*rotbond_id+1],\n"
"				                            s*kerconst_conform->rotbonds_unit_vectors_const[3*rotbond_id+2],\n"
"				                            native_cos(rotation_angle));\n"
"				rotation_movingvec = (float4)(kerconst_conform->rotbonds_moving_vectors_const[3*rotbond_id],\n"
"				                              kerconst_conform->rotbonds_moving_vectors_const[3*rotbond_id+1],\n"
"				                              kerconst_conform->rotbonds_moving_vectors_const[3*rotbond_id+2],0.0f);\n"
"				// Performing additionally the first movement which\n"
"				// is needed only if rotating around rotatable bond\n"
"				atom_to_rotate -= rotation_movingvec;\n"
"			}\n"
"			// Performing rotation and final movement\n"
"			calc_coords[atom_id] = quaternion_rotate(atom_to_rotate,rotation_unitvec) + rotation_movingvec;\n"
"		} // End if-statement not dummy rotation\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"	} // End rotation_counter for-loop\n"
"\n"
"	// ================================================\n"
"	// CALCULATING INTERMOLECULAR ENERGY\n"
"	// ================================================\n"
"	float weights[8];\n"
"	float cube[8];\n"
"	for ( int atom_id = tidx;\n"
"	          atom_id < dockpars_num_of_atoms;\n"
"	          atom_id+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		if (kerconst_interintra->ignore_inter_const[atom_id]>0) // first two atoms of a flex res are to be ignored here\n"
"			continue;\n"
"		uint atom_typeid = kerconst_interintra->atom_types_map_const[atom_id];\n"
"		float x = calc_coords[atom_id].x;\n"
"		float y = calc_coords[atom_id].y;\n"
"		float z = calc_coords[atom_id].z;\n"
"		float q = kerconst_interintra->atom_charges_const[atom_id];\n"
"		if ((x < 0) || (y < 0) || (z < 0) || (x >= dockpars_gridsize_x-1)\n"
"		                                  || (y >= dockpars_gridsize_y-1)\n"
"		                                  || (z >= dockpars_gridsize_z-1)){\n"
"			partial_energies[tidx] += 16777216.0f; //100000.0f;\n"
"			#if defined (DEBUG_ENERGY_KERNEL)\n"
"			partial_interE[tidx] += 16777216.0f;\n"
"			#endif\n"
"			continue; // get on with loop as our work here is done (we crashed into the walls)\n"
"		}\n"
"		// Getting coordinates\n"
"		float x_low  = floor(x);\n"
"		float y_low  = floor(y);\n"
"		float z_low  = floor(z);\n"
"\n"
"		// Grid value at 000\n"
"		__global const float* grid_value_000 = dockpars_fgrids + ((ulong)(x_low  + y_low*g1  + z_low*g2)<<2);\n"
"\n"
"		float dx = x - x_low;\n"
"		float omdx = 1.0f - dx;\n"
"		float dy = y - y_low;\n"
"		float omdy = 1.0f - dy;\n"
"		float dz = z - z_low;\n"
"		float omdz = 1.0f - dz;\n"
"\n"
"		// Calculating interpolation weights\n"
"		weights [idx_000] = omdx*omdy*omdz;\n"
"		weights [idx_010] = omdx*dy*omdz;\n"
"		weights [idx_001] = omdx*omdy*dz;\n"
"		weights [idx_011] = omdx*dy*dz;\n"
"		weights [idx_100] = dx*omdy*omdz;\n"
"		weights [idx_110] = dx*dy*omdz;\n"
"		weights [idx_101] = dx*omdy*dz;\n"
"		weights [idx_111] = dx*dy*dz;\n"
"\n"
"		ulong mul_tmp = atom_typeid*g3<<2;\n"
"		cube[0] = *(grid_value_000+mul_tmp+0);\n"
"		cube[1] = *(grid_value_000+mul_tmp+1);\n"
"		cube[2] = *(grid_value_000+mul_tmp+2);\n"
"		cube[3] = *(grid_value_000+mul_tmp+3);\n"
"		cube[4] = *(grid_value_000+mul_tmp+4);\n"
"		cube[5] = *(grid_value_000+mul_tmp+5);\n"
"		cube[6] = *(grid_value_000+mul_tmp+6);\n"
"		cube[7] = *(grid_value_000+mul_tmp+7);\n"
"		// Calculating affinity energy\n"
"		partial_energies[tidx] += cube[0]*weights[0] + cube[1]*weights[1] + cube[2]*weights[2] + cube[3]*weights[3] + cube[4]*weights[4] + cube[5]*weights[5] + cube[6]*weights[6] + cube[7]*weights[7];\n"
"		#if defined (DEBUG_ENERGY_KERNEL)\n"
"		partial_interE[tidx] += cube[0]*weights[0] + cube[1]*weights[1] + cube[2]*weights[2] + cube[3]*weights[3] + cube[4]*weights[4] + cube[5]*weights[5] + cube[6]*weights[6] + cube[7]*weights[7];\n"
"		#endif\n"
"\n"
"		// Capturing electrostatic values\n"
"		atom_typeid = dockpars_num_of_map_atypes;\n"
"\n"
"		mul_tmp = atom_typeid*g3<<2; // different atom type id to get charge IA\n"
"		cube[0] = *(grid_value_000+mul_tmp+0);\n"
"		cube[1] = *(grid_value_000+mul_tmp+1);\n"
"		cube[2] = *(grid_value_000+mul_tmp+2);\n"
"		cube[3] = *(grid_value_000+mul_tmp+3);\n"
"		cube[4] = *(grid_value_000+mul_tmp+4);\n"
"		cube[5] = *(grid_value_000+mul_tmp+5);\n"
"		cube[6] = *(grid_value_000+mul_tmp+6);\n"
"		cube[7] = *(grid_value_000+mul_tmp+7);\n"
"\n"
"		// Calculating affinity energy\n"
"		partial_energies[tidx] += q * (cube[0]*weights[0] + cube[1]*weights[1] + cube[2]*weights[2] + cube[3]*weights[3] + cube[4]*weights[4] + cube[5]*weights[5] + cube[6]*weights[6] + cube[7]*weights[7]);\n"
"		#if defined (DEBUG_ENERGY_KERNEL)\n"
"		partial_interE[tidx] += q *(cube[0]*weights[0] + cube[1]*weights[1] + cube[2]*weights[2] + cube[3]*weights[3] + cube[4]*weights[4] + cube[5]*weights[5] + cube[6]*weights[6] + cube[7]*weights[7]);\n"
"		#endif\n"
"\n"
"		// Need only magnitude of charge from here on down\n"
"		q = fabs(q);\n"
"		// Capturing desolvation values (atom_typeid+1 compared to above => mul_tmp + g3*4)\n"
"		mul_tmp += g3<<2;\n"
"		cube[0] = *(grid_value_000+mul_tmp+0);\n"
"		cube[1] = *(grid_value_000+mul_tmp+1);\n"
"		cube[2] = *(grid_value_000+mul_tmp+2);\n"
"		cube[3] = *(grid_value_000+mul_tmp+3);\n"
"		cube[4] = *(grid_value_000+mul_tmp+4);\n"
"		cube[5] = *(grid_value_000+mul_tmp+5);\n"
"		cube[6] = *(grid_value_000+mul_tmp+6);\n"
"		cube[7] = *(grid_value_000+mul_tmp+7);\n"
"\n"
"		// Calculating affinity energy\n"
"		partial_energies[tidx] += q * (cube[0]*weights[0] + cube[1]*weights[1] + cube[2]*weights[2] + cube[3]*weights[3] + cube[4]*weights[4] + cube[5]*weights[5] + cube[6]*weights[6] + cube[7]*weights[7]);\n"
"		#if defined (DEBUG_ENERGY_KERNEL)\n"
"		partial_interE[tidx] += q *(cube[0]*weights[0] + cube[1]*weights[1] + cube[2]*weights[2] + cube[3]*weights[3] + cube[4]*weights[4] + cube[5]*weights[5] + cube[6]*weights[6] + cube[7]*weights[7]);\n"
"		#endif\n"
"	} // End atom_id for-loop (INTERMOLECULAR ENERGY)\n"
"\n"
"#if defined (DEBUG_ENERGY_KERNEL)\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// reduction to calculate energy\n"
"	for ( int off=NUM_OF_THREADS_PER_BLOCK>>1; off>0; off >>= 1)\n"
"	{\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		if (tidx < off)\n"
"			partial_intraE[tidx] += partial_intraE[tidx+off];\n"
"	}\n"
"#endif\n"
"\n"
"	// In paper: intermolecular and internal energy calculation\n"
"	// are independent from each other, -> NO BARRIER NEEDED\n"
"	// but require different operations,\n"
"	// thus, they can be executed only sequentially on the GPU.\n"
"	float delta_distance = 0.5f*dockpars_smooth;\n"
"	float smoothed_distance;\n"
"\n"
"	// ================================================\n"
"	// CALCULATING INTRAMOLECULAR ENERGY\n"
"	// ================================================\n"
"	for ( int contributor_counter = tidx;\n"
"	          contributor_counter < dockpars_num_of_intraE_contributors;\n"
"	          contributor_counter +=NUM_OF_THREADS_PER_BLOCK)\n"
"#if 0\n"
"if (tidx == 0) {\n"
"	for ( int contributor_counter = 0;\n"
"	          contributor_counter < dockpars_num_of_intraE_contributors;\n"
"	          contributor_counter ++)\n"
"#endif\n"
"	{\n"
"#if 0\n"
"		// Only for testing smoothing\n"
"		float smoothed_intraE = 0.0f;\n"
"		float raw_intraE_vdw_hb = 0.0f;\n"
"		float raw_intraE_el     = 0.0f;\n"
"		float raw_intraE_sol    = 0.0f;\n"
"		float raw_intraE        = 0.0f;\n"
"#endif\n"
"		// Getting atom IDs\n"
"		uint atom1_id = kerconst_intracontrib->intraE_contributors_const[2*contributor_counter];\n"
"		uint atom2_id = kerconst_intracontrib->intraE_contributors_const[2*contributor_counter+1];\n"
"\n"
"		// Calculating vector components of vector going\n"
"		// from first atom's to second atom's coordinates\n"
"		float subx = calc_coords[atom1_id].x - calc_coords[atom2_id].x;\n"
"		float suby = calc_coords[atom1_id].y - calc_coords[atom2_id].y;\n"
"		float subz = calc_coords[atom1_id].z - calc_coords[atom2_id].z;\n"
"\n"
"		// Calculating atomic_distance\n"
"		float atomic_distance = native_sqrt(subx*subx + suby*suby + subz*subz)*dockpars_grid_spacing;\n"
"\n"
"		// Getting type IDs\n"
"		uint atom1_typeid = kerconst_interintra->atom_types_const[atom1_id];\n"
"		uint atom2_typeid = kerconst_interintra->atom_types_const[atom2_id];\n"
"\n"
"		uint atom1_type_vdw_hb = kerconst_intra->atom_types_reqm_const [atom1_typeid];\n"
"		uint atom2_type_vdw_hb = kerconst_intra->atom_types_reqm_const [atom2_typeid];\n"
"\n"
"		// ------------------------------------------------\n"
"		// Required only for flexrings\n"
"		// Checking if this is a CG-G0 atomic pair.\n"
"		// If so, then adding energy term (E = G * distance).\n"
"		// Initial specification required NON-SMOOTHED distance.\n"
"		// This interaction is evaluated at any distance,\n"
"		// so no cuttoffs considered here!\n"
"		// vbond is G when calculating flexrings, 0.0 otherwise\n"
"		float vbond = G * (float)(((atom1_type_vdw_hb == ATYPE_CG_IDX) && (atom2_type_vdw_hb == ATYPE_G0_IDX)) ||\n"
"		                          ((atom1_type_vdw_hb == ATYPE_G0_IDX) && (atom2_type_vdw_hb == ATYPE_CG_IDX)));\n"
"		partial_energies[tidx] += vbond * atomic_distance;\n"
"\n"
"		// Calculating energy contributions\n"
"		// Cuttoff1: internuclear-distance at 8A only for vdw and hbond\n"
"		if (atomic_distance < 8.0f)\n"
"		{\n"
"			uint idx = atom1_typeid * dockpars_num_of_atypes + atom2_typeid;\n"
"			ushort exps = kerconst_intra->VWpars_exp_const[idx];\n"
"			char m=(exps & 0xFF00)>>8;\n"
"			char n=(exps & 0xFF);\n"
"			// Getting optimum pair distance (opt_distance)\n"
"			float opt_distance = kerconst_intra->reqm_AB_const[idx];\n"
"\n"
"			// Getting smoothed distance\n"
"			// smoothed_distance = function(atomic_distance, opt_distance)\n"
"			float opt_dist_delta = opt_distance - atomic_distance;\n"
"			if(fabs(opt_dist_delta)>=delta_distance){\n"
"				smoothed_distance = atomic_distance + copysign(delta_distance,opt_dist_delta);\n"
"			} else smoothed_distance = opt_distance;\n"
"			// Calculating van der Waals / hydrogen bond term\n"
"			partial_energies[tidx] += (kerconst_intra->VWpars_AC_const[idx]-native_powr(smoothed_distance,m-n)*kerconst_intra->VWpars_BD_const[idx])\n"
"			                          *native_powr(smoothed_distance,-m);\n"
"			#if defined (DEBUG_ENERGY_KERNEL)\n"
"			partial_intraE[tidx] += (kerconst_intra->VWpars_AC_const[idx]-native_powr(smoothed_distance,m-n)*kerconst_intra->VWpars_BD_const[idx])\n"
"			                        *native_powr(smoothed_distance,-m));\n"
"			#endif\n"
"		} // if cuttoff1 - internuclear-distance at 8A\n"
"\n"
"		// Calculating energy contributions\n"
"		// Cuttoff2: internuclear-distance at 20.48A only for el and sol.\n"
"		if (atomic_distance < 20.48f)\n"
"		{\n"
"			if(atomic_distance<dockpars_elec_min_distance) atomic_distance=dockpars_elec_min_distance;\n"
"			float q1 = kerconst_interintra->atom_charges_const[atom1_id];\n"
"			float q2 = kerconst_interintra->atom_charges_const[atom2_id];\n"
"			float dist2 = atomic_distance*atomic_distance;\n"
"			// Calculating desolvation term\n"
"			// 1/25.92 = 0.038580246913580245\n"
"			float desolv_energy =  ((kerconst_intra->dspars_S_const[atom1_typeid] +\n"
"			                         dockpars_qasp*fabs(q1)) * kerconst_intra->dspars_V_const[atom2_typeid] +\n"
"			                        (kerconst_intra->dspars_S_const[atom2_typeid] +\n"
"			                         dockpars_qasp*fabs(q2)) * kerconst_intra->dspars_V_const[atom1_typeid]) *\n"
"			                       native_divide (\n"
"			                                      dockpars_coeff_desolv*(12.96f-0.1063f*dist2*(1.0f-0.001947f*dist2)),\n"
"			                                      (12.96f+dist2*(0.4137f+dist2*(0.00357f+0.000112f*dist2)))\n"
"			                                     );\n"
"			// Calculating electrostatic term\n"
"			float dist_shift=atomic_distance+1.26366f;\n"
"			dist2=dist_shift*dist_shift;\n"
"			float diel = 1.10859f*native_recip(dist2)+0.010358f;\n"
"			float es_energy = dockpars_coeff_elec * q1 * q2 * native_recip(atomic_distance);\n"
"			partial_energies[tidx] += diel * es_energy + desolv_energy;\n"
"			#if 0\n"
"			smoothed_intraE += native_divide (\n"
"			                                  dockpars_coeff_elec * q1 * q2,\n"
"			                                  atomic_distance * (DIEL_A + native_divide(DIEL_B,(1.0f + DIEL_K*native_exp(-DIEL_B_TIMES_H*atomic_distance))))\n"
"			                                 ) +\n"
"			                   ((kerconst_intra->dspars_S_const[atom1_typeid] +\n"
"			                     dockpars_qasp*fabs(q1))*kerconst_intra->dspars_V_const[atom2_typeid] +\n"
"			                    (kerconst_intra->dspars_S_const[atom2_typeid] +\n"
"			                     dockpars_qasp*fabs(q2))*kerconst_intra->dspars_V_const[atom1_typeid]) *\n"
"			                   dockpars_coeff_desolv*native_exp(-0.03858025f*native_powr(atomic_distance, 2));\n"
"			raw_intraE_el = native_divide (\n"
"			                               dockpars_coeff_elec * q1 * q2,\n"
"			                               atomic_distance * (DIEL_A + native_divide(DIEL_B,(1.0f + DIEL_K*native_exp(-DIEL_B_TIMES_H*atomic_distance))))\n"
"			                              );\n"
"			raw_intraE_sol = ((kerconst_intra->dspars_S_const[atom1_typeid] +\n"
"			                   dockpars_qasp*fabs(q1))*kerconst_intra->dspars_V_const[atom2_typeid] +\n"
"			                  (kerconst_intra->dspars_S_const[atom2_typeid] +\n"
"			                   dockpars_qasp*fabs(q2))*kerconst_intra->dspars_V_const[atom1_typeid]) *\n"
"			                 dockpars_coeff_desolv*native_exp(-0.03858025f*native_powr(atomic_distance, 2));\n"
"			#endif\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL)\n"
"			partial_intraE[tidx] += native_divide (\n"
"			                                       dockpars_coeff_elec * q1 * q2,\n"
"			                                       atomic_distance * (DIEL_A + native_divide(DIEL_B,(1.0f + DIEL_K*native_exp(-DIEL_B_TIMES_H*atomic_distance))))\n"
"			                                      ) +\n"
"			                        ((kerconst_intra->dspars_S_const[atom1_typeid] +\n"
"			                          dockpars_qasp*fabs(q1)) * kerconst_intra->dspars_V_const[atom2_typeid] +\n"
"			                         (kerconst_intra->dspars_S_const[atom2_typeid] +\n"
"			                          dockpars_qasp*fabs(q2))*kerconst_intra->dspars_V_const[atom1_typeid]) *\n"
"			                        dockpars_coeff_desolv*native_exp(-0.03858025f*native_powr(atomic_distance, 2));\n"
"			#endif\n"
"		} // if cuttoff2 - internuclear-distance at 20.48A\n"
"	} // End contributor_counter for-loop (INTRAMOLECULAR ENERGY)\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// reduction to calculate energy\n"
"	for ( int off=NUM_OF_THREADS_PER_BLOCK>>1; off>0; off >>= 1)\n"
"	{\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		if (tidx < off)\n"
"		{\n"
"			partial_energies[tidx] += partial_energies[tidx+off];\n"
"#if defined (DEBUG_ENERGY_KERNEL)\n"
"			partial_intraE[tidx] += partial_intraE[tidx+off];\n"
"#endif\n"
"		}\n"
"	}\n"
"	if (tidx == 0)\n"
"		*energy = partial_energies[0];\n"
"}\n"
"\n"
"/*\n"
"\n"
"AutoDock-GPU, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"For some of the code, Copyright (C) 2019 Computational Structural Biology Center, the Scripps Research Institute.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This library is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU Lesser General Public\n"
"License as published by the Free Software Foundation; either\n"
"version 2.1 of the License, or (at your option) any later version.\n"
"\n"
"This library is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"Lesser General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU Lesser General Public\n"
"License along with this library; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n"
"\n"
"*/\n"
"\n"
"\n"
"/*\n"
"*/\n"
"// All related pragmas are in defines.h (accesible by host and device code)\n"
"\n"
"\n"
"// The GPU device function calculates the energy's gradient (forces or derivatives) \n"
"// of the entity described by genotype, dockpars and the ligand-data\n"
"// arrays in constant memory and returns it in the \"gradient_genotype\" parameter. \n"
"// The parameter \"run_id\" has to be equal to the ID of the run \n"
"// whose population includes the current entity (which can be determined with get_group_id(0)), \n"
"// since this determines which reference orientation should be used.\n"
"\n"
"//#define PRINT_GRAD_TRANSLATION_GENES\n"
"//#define PRINT_GRAD_ROTATION_GENES\n"
"//#define PRINT_GRAD_TORSION_GENES\n"
"\n"
"// The following is a scaling of gradients.\n"
"// Initially all genotypes and gradients\n"
"// were expressed in grid-units (translations)\n"
"// and sexagesimal degrees (rotation and torsion angles).\n"
"// Expressing them using angstroms / radians\n"
"// might help gradient-based minimizers.\n"
"// This conversion is applied to final gradients.\n"
"#define CONVERT_INTO_ANGSTROM_RADIAN\n"
"\n"
"// Scaling factor to multiply the gradients of \n"
"// the genes expressed in degrees (all genes except the first three) \n"
"// (GRID-SPACING * GRID-SPACING) / (DEG_TO_RAD * DEG_TO_RAD) = 461.644\n"
"#define SCFACTOR_ANGSTROM_RADIAN 1.0f/(DEG_TO_RAD * DEG_TO_RAD)\n"
"\n"
"void map_priv_angle(float* angle)\n"
"// The GPU device function maps\n"
"// the input parameter to the interval 0...360\n"
"// (supposing that it is an angle).\n"
"{\n"
"	while (*angle >= 360.0f) {\n"
"		*angle -= 360.0f;\n"
"	}\n"
"	while (*angle < 0.0f) {\n"
"		*angle += 360.0f;\n"
"	}\n"
"}\n"
"\n"
"#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable\n"
"\n"
"// Atomic operations used in gradients of intra contributors.\n"
"// Only atomic_cmpxchg() works on floats. \n"
"// So for atomic add on floats, this link was used:\n"
"// https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/\n"
"void atomicAdd_g_f(volatile __local float *addr, float val)\n"
"{\n"
"	union{\n"
"		unsigned int u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 + val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __local unsigned int *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"\n"
"void atomicSub_g_f(volatile __local float *addr, float val)\n"
"{\n"
"	union{\n"
"		unsigned int u32;\n"
"		float f32;\n"
"	} next, expected, current;\n"
"\n"
"	current.f32 = *addr;\n"
"\n"
"	do{\n"
"		expected.f32 = current.f32;\n"
"		next.f32 = expected.f32 - val;\n"
"		current.u32 = atomic_cmpxchg( (volatile __local unsigned int *)addr, expected.u32, next.u32);\n"
"	} while( current.u32 != expected.u32 );\n"
"}\n"
"\n"
"void gpu_calc_gradient(\n"
"                             int    dockpars_rotbondlist_length,\n"
"                             int    dockpars_num_of_atoms,\n"
"                             int    dockpars_true_ligand_atoms,\n"
"                             int    dockpars_gridsize_x,\n"
"                             int    dockpars_gridsize_y,\n"
"                             int    dockpars_gridsize_z,\n"
"                                                                         // g1 = gridsize_x\n"
"                             uint   dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"                             uint   dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"              __global const float* restrict dockpars_fgrids, // This is too large to be allocated in __constant \n"
"                             int    dockpars_num_of_atypes,\n"
"                             int    dockpars_num_of_map_atypes,\n"
"                             int    dockpars_num_of_intraE_contributors,\n"
"                             float  dockpars_grid_spacing,\n"
"                             float  dockpars_coeff_elec,\n"
"                             float  dockpars_elec_min_distance,\n"
"                             float  dockpars_qasp,\n"
"                             float  dockpars_coeff_desolv,\n"
"                             float  dockpars_smooth,\n"
"\n"
"                             // Some OpenCL compilers don't allow declaring\n"
"                             // local variables within non-kernel functions.\n"
"                             // These local variables must be declared in a kernel,\n"
"                             // and then passed to non-kernel functions.\n"
"                     __local float* genotype,\n"
"                     __local float* energy,\n"
"                     __local int*   run_id,\n"
"\n"
"                    __local float4* calc_coords,\n"
"\n"
"                 __constant kernelconstant_interintra*   kerconst_interintra,\n"
"             __global const kernelconstant_intracontrib* kerconst_intracontrib,\n"
"                 __constant kernelconstant_intra*        kerconst_intra,\n"
"                 __constant kernelconstant_rotlist*      kerconst_rotlist,\n"
"                 __constant kernelconstant_conform*      kerconst_conform,\n"
"\n"
"                 __constant int*    rotbonds_const,\n"
"             __global const int*    rotbonds_atoms_const,\n"
"                 __constant int*    num_rotating_atoms_per_rotbond_const,\n"
"\n"
"                            int     dockpars_num_of_genes,\n"
"                    __local float*  gradient_inter_x,\n"
"                    __local float*  gradient_inter_y,\n"
"                    __local float*  gradient_inter_z,\n"
"                    __local float*  gradient_intra_x,\n"
"                    __local float*  gradient_intra_y,\n"
"                    __local float*  gradient_intra_z,\n"
"                    __local float*  gradient_genotype\n"
"                      )\n"
"{\n"
"	int tidx = get_local_id(0);\n"
"	// Initializing gradients (forces)\n"
"	// Derived from autodockdev/maps.py\n"
"	for (int atom_id = tidx;\n"
"	         atom_id < dockpars_num_of_atoms;\n"
"	         atom_id+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		// Intermolecular gradients\n"
"		gradient_inter_x[atom_id] = 0.0f;\n"
"		gradient_inter_y[atom_id] = 0.0f;\n"
"		gradient_inter_z[atom_id] = 0.0f;\n"
"		// Intramolecular gradients\n"
"		gradient_intra_x[atom_id] = 0.0f;\n"
"		gradient_intra_y[atom_id] = 0.0f;\n"
"		gradient_intra_z[atom_id] = 0.0f;\n"
"	}\n"
"\n"
"	// Initializing gradient genotypes\n"
"	for ( int gene_cnt = tidx;\n"
"	          gene_cnt < dockpars_num_of_genes;\n"
"	          gene_cnt+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		gradient_genotype[gene_cnt] = 0.0f;\n"
"	}\n"
"\n"
"	// General rotation moving vector\n"
"	float4 genrot_movingvec;\n"
"\n"
"	// Convert orientation genes from sex. to radians\n"
"	float phi         = genotype[3] * DEG_TO_RAD;\n"
"	float theta       = genotype[4] * DEG_TO_RAD;\n"
"	float genrotangle = genotype[5] * DEG_TO_RAD;\n"
"\n"
"	float4 genrot_unitvec;\n"
"	float is_theta_gt_pi, sin_half_rotangle, sin_theta;\n"
"	if(dockpars_true_ligand_atoms){\n"
"		genrot_movingvec.x = genotype[0];\n"
"		genrot_movingvec.y = genotype[1];\n"
"		genrot_movingvec.z = genotype[2];\n"
"		genrot_movingvec.w = 0.0f;\n"
"		sin_theta = native_sin(theta);\n"
"		float cos_theta = native_cos(theta);\n"
"		sin_half_rotangle = native_sin(genrotangle*0.5f);\n"
"		genrot_unitvec.x = sin_half_rotangle*sin_theta*native_cos(phi);\n"
"		genrot_unitvec.y = sin_half_rotangle*sin_theta*native_sin(phi);\n"
"		genrot_unitvec.z = sin_half_rotangle*cos_theta;\n"
"		genrot_unitvec.w = native_cos(genrotangle*0.5f);\n"
"		is_theta_gt_pi = 1.0f-2.0f*(float)(sin_theta < 0.0f);\n"
"	}\n"
"\n"
"	uint g1 = dockpars_gridsize_x;\n"
"	uint g2 = dockpars_gridsize_x_times_y;\n"
"	uint g3 = dockpars_gridsize_x_times_y_times_z;\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// ================================================\n"
"	// CALCULATING ATOMIC POSITIONS AFTER ROTATIONS\n"
"	// ================================================\n"
"	for ( int rotation_counter = tidx;\n"
"	          rotation_counter < dockpars_rotbondlist_length;\n"
"	          rotation_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		int rotation_list_element = kerconst_rotlist->rotlist_const[rotation_counter];\n"
"		if ((rotation_list_element & RLIST_DUMMY_MASK) == 0) // If not dummy rotation\n"
"		{\n"
"			int atom_id = rotation_list_element & RLIST_ATOMID_MASK;\n"
"			// Capturing atom coordinates\n"
"			float4 atom_to_rotate = calc_coords[atom_id];\n"
"			// initialize with general rotation values\n"
"			float4 rotation_unitvec;\n"
"			float4 rotation_movingvec;\n"
"			if (atom_id < dockpars_true_ligand_atoms){\n"
"				rotation_unitvec = genrot_unitvec;\n"
"				rotation_movingvec = genrot_movingvec;\n"
"			} else{\n"
"				rotation_unitvec.x = 0.0f; rotation_unitvec.y = 0.0f; rotation_unitvec.z = 0.0f;\n"
"				rotation_unitvec.w = 1.0f;\n"
"				rotation_movingvec.x = 0.0f; rotation_movingvec.y = 0.0f; rotation_movingvec.z = 0.0f;\n"
"				rotation_movingvec.w = 0.0f;\n"
"			}\n"
"			if ((rotation_list_element & RLIST_GENROT_MASK) == 0) // If rotating around rotatable bond\n"
"			{\n"
"				uint rotbond_id = (rotation_list_element & RLIST_RBONDID_MASK) >> RLIST_RBONDID_SHIFT;\n"
"				float rotation_angle = genotype[6+rotbond_id]*DEG_TO_RAD*0.5f;\n"
"				float s = native_sin(rotation_angle);\n"
"				rotation_unitvec = (float4)(s*kerconst_conform->rotbonds_unit_vectors_const[3*rotbond_id],\n"
"							    s*kerconst_conform->rotbonds_unit_vectors_const[3*rotbond_id+1],\n"
"							    s*kerconst_conform->rotbonds_unit_vectors_const[3*rotbond_id+2],\n"
"							    native_cos(rotation_angle));\n"
"				rotation_movingvec = (float4)(kerconst_conform->rotbonds_moving_vectors_const[3*rotbond_id],\n"
"							      kerconst_conform->rotbonds_moving_vectors_const[3*rotbond_id+1],\n"
"							      kerconst_conform->rotbonds_moving_vectors_const[3*rotbond_id+2],0.0f);\n"
"				// Performing additionally the first movement which\n"
"				// is needed only if rotating around rotatable bond\n"
"				atom_to_rotate -= rotation_movingvec;\n"
"			}\n"
"			// Performing rotation and final movement\n"
"			calc_coords[atom_id] = quaternion_rotate(atom_to_rotate,rotation_unitvec) + rotation_movingvec;\n"
"		} // End if-statement not dummy rotation\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"	} // End rotation_counter for-loop\n"
"\n"
"	// ================================================\n"
"	// CALCULATING INTERMOLECULAR GRADIENTS\n"
"	// ================================================\n"
"	for ( int atom_id = tidx;\n"
"	          atom_id < dockpars_num_of_atoms;\n"
"	          atom_id+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		if (kerconst_interintra->ignore_inter_const[atom_id]>0) // first two atoms of a flex res are to be ignored here\n"
"			continue;\n"
"		uint atom_typeid = kerconst_interintra->atom_types_map_const[atom_id];\n"
"		float x = calc_coords[atom_id].x;\n"
"		float y = calc_coords[atom_id].y;\n"
"		float z = calc_coords[atom_id].z;\n"
"		float q = kerconst_interintra->atom_charges_const[atom_id];\n"
"\n"
"		if ((x < 0) || (y < 0) || (z < 0) || (x >= dockpars_gridsize_x-1)\n"
"		                                  || (y >= dockpars_gridsize_y-1)\n"
"		                                  || (z >= dockpars_gridsize_z-1)) {\n"
"			// Setting gradients (forces) penalties.\n"
"			// These are valid as long as they are high\n"
"			gradient_inter_x[atom_id] += 16777216.0f;\n"
"			gradient_inter_y[atom_id] += 16777216.0f;\n"
"			gradient_inter_z[atom_id] += 16777216.0f;\n"
"		}\n"
"		else\n"
"		{\n"
"			// Getting coordinates\n"
"			uint x_low  = (uint)floor(x);\n"
"			uint y_low  = (uint)floor(y);\n"
"			uint z_low  = (uint)floor(z);\n"
"			uint x_high = (uint)ceil(x);\n"
"			uint y_high = (uint)ceil(y);\n"
"			uint z_high = (uint)ceil(z);\n"
"			float dx = x - x_low;\n"
"			float dy = y - y_low;\n"
"			float dz = z - z_low;\n"
"\n"
"			//printf(\"%-15s %-5u %-10.8f %-10.8f %-10.8f\\n\", \"dx,dy,dz\", atom_id, dx, dy, dz);\n"
"\n"
"			// Calculating interpolation weights\n"
"			float weights[8];\n"
"			weights [idx_000] = (1.0f-dx)*(1.0f-dy)*(1.0f-dz);\n"
"			weights [idx_100] = dx*(1.0f-dy)*(1.0f-dz);\n"
"			weights [idx_010] = (1.0f-dx)*dy*(1.0f-dz);\n"
"			weights [idx_110] = dx*dy*(1.0f-dz);\n"
"			weights [idx_001] = (1.0f-dx)*(1.0f-dy)*dz;\n"
"			weights [idx_101] = dx*(1.0f-dy)*dz;\n"
"			weights [idx_011] = (1.0f-dx)*dy*dz;\n"
"			weights [idx_111] = dx*dy*dz;\n"
"\n"
"			// Capturing affinity values\n"
"			uint ylow_times_g1  = y_low*g1;\n"
"			uint yhigh_times_g1 = y_high*g1;\n"
"		  	uint zlow_times_g2  = z_low*g2;\n"
"			uint zhigh_times_g2 = z_high*g2;\n"
"\n"
"			// Grid offset\n"
"			ulong offset_cube_000 = (x_low  + ylow_times_g1  + zlow_times_g2)<<2;\n"
"			ulong offset_cube_100 = (x_high + ylow_times_g1  + zlow_times_g2)<<2;\n"
"			ulong offset_cube_010 = (x_low  + yhigh_times_g1 + zlow_times_g2)<<2;\n"
"			ulong offset_cube_110 = (x_high + yhigh_times_g1 + zlow_times_g2)<<2;\n"
"			ulong offset_cube_001 = (x_low  + ylow_times_g1  + zhigh_times_g2)<<2;\n"
"			ulong offset_cube_101 = (x_high + ylow_times_g1  + zhigh_times_g2)<<2;\n"
"			ulong offset_cube_011 = (x_low  + yhigh_times_g1 + zhigh_times_g2)<<2;\n"
"			ulong offset_cube_111 = (x_high + yhigh_times_g1 + zhigh_times_g2)<<2;\n"
"\n"
"			ulong mul_tmp = atom_typeid*g3<<2;\n"
"\n"
"			float cube[8];\n"
"			cube [idx_000] = *(dockpars_fgrids + offset_cube_000 + mul_tmp);\n"
"			cube [idx_100] = *(dockpars_fgrids + offset_cube_100 + mul_tmp);\n"
"			cube [idx_010] = *(dockpars_fgrids + offset_cube_010 + mul_tmp);\n"
"			cube [idx_110] = *(dockpars_fgrids + offset_cube_110 + mul_tmp);\n"
"			cube [idx_001] = *(dockpars_fgrids + offset_cube_001 + mul_tmp);\n"
"			cube [idx_101] = *(dockpars_fgrids + offset_cube_101 + mul_tmp);\n"
"			cube [idx_011] = *(dockpars_fgrids + offset_cube_011 + mul_tmp);\n"
"			cube [idx_111] = *(dockpars_fgrids + offset_cube_111 + mul_tmp);\n"
"\n"
"			// -------------------------------------------------------------------\n"
"			// Deltas dx, dy, dz are already normalized \n"
"			// (by host/src/getparameters.cpp) in AutoDock-GPU.\n"
"			// The correspondance between vertices in xyz axes is:\n"
"			// 0, 1, 2, 3, 4, 5, 6, 7  and  000, 100, 010, 001, 101, 110, 011, 111\n"
"			// -------------------------------------------------------------------\n"
"			/*\n"
"			    deltas: (x-x0)/(x1-x0), (y-y0...\n"
"			    vertices: (000, 100, 010, 001, 101, 110, 011, 111)        \n"
"\n"
"			          Z\n"
"			          '\n"
"			          3 - - - - 6\n"
"			         /.        /|\n"
"			        4 - - - - 7 |\n"
"			        | '       | |\n"
"			        | 0 - - - + 2 -- Y\n"
"			        '/        |/\n"
"			        1 - - - - 5\n"
"			       /\n"
"			      X\n"
"			*/\n"
"\n"
"			// Intermediate values for vectors in x-direction\n"
"			float x10, x52, x43, x76;\n"
"			float vx_z0, vx_z1;\n"
"\n"
"			// Intermediate values for vectors in y-direction\n"
"			float y20, y51, y63, y74;\n"
"			float vy_z0, vy_z1;\n"
"\n"
"			// Intermediate values for vectors in z-direction\n"
"			float z30, z41, z62, z75;\n"
"			float vz_y0, vz_y1;\n"
"\n"
"			// -------------------------------------------------------------------\n"
"			// Calculating gradients (forces) corresponding to \n"
"			// \"atype\" intermolecular energy\n"
"			// Derived from autodockdev/maps.py\n"
"			// -------------------------------------------------------------------\n"
"\n"
"			// Vector in x-direction\n"
"			x10 = cube [idx_100] - cube [idx_000]; // z = 0\n"
"			x52 = cube [idx_110] - cube [idx_010]; // z = 0\n"
"			x43 = cube [idx_101] - cube [idx_001]; // z = 1\n"
"			x76 = cube [idx_111] - cube [idx_011]; // z = 1\n"
"			vx_z0 = (1.0f - dy) * x10 + dy * x52;     // z = 0\n"
"			vx_z1 = (1.0f - dy) * x43 + dy * x76;     // z = 1\n"
"			gradient_inter_x[atom_id] += (1.0f - dz) * vx_z0 + dz * vx_z1;\n"
"\n"
"			// Vector in y-direction\n"
"			y20 = cube[idx_010] - cube [idx_000];	// z = 0\n"
"			y51 = cube[idx_110] - cube [idx_100];	// z = 0\n"
"			y63 = cube[idx_011] - cube [idx_001];	// z = 1\n"
"			y74 = cube[idx_111] - cube [idx_101];	// z = 1\n"
"			vy_z0 = (1.0f - dx) * y20 + dx * y51;	// z = 0\n"
"			vy_z1 = (1.0f - dx) * y63 + dx * y74;	// z = 1\n"
"			gradient_inter_y[atom_id] += (1.0f - dz) * vy_z0 + dz * vy_z1;\n"
"\n"
"			// Vectors in z-direction\n"
"			z30 = cube [idx_001] - cube [idx_000];	// y = 0\n"
"			z41 = cube [idx_101] - cube [idx_100];	// y = 0\n"
"			z62 = cube [idx_011] - cube [idx_010];	// y = 1 \n"
"			z75 = cube [idx_111] - cube [idx_110];	// y = 1\n"
"			vz_y0 = (1.0f - dx) * z30 + dx * z41;	// y = 0\n"
"			vz_y1 = (1.0f - dx) * z62 + dx * z75;	// y = 1\n"
"			gradient_inter_z[atom_id] += (1.0f - dy) * vz_y0 + dy * vz_y1;\n"
"\n"
"			//printf(\"%-15s %-3u %-10.8f %-10.8f %-10.8f %-10.8f %-10.8f %-10.8f\\n\", \"atom aff\", atom_id, vx_z0, vx_z1, vy_z0, vy_z1, vz_y0, vz_y1);\n"
"\n"
"			// -------------------------------------------------------------------\n"
"			// Calculating gradients (forces) corresponding to \n"
"			// \"elec\" intermolecular energy\n"
"			// Derived from autodockdev/maps.py\n"
"			// -------------------------------------------------------------------\n"
"\n"
"			// Capturing electrostatic values\n"
"			atom_typeid = dockpars_num_of_map_atypes;\n"
"\n"
"			mul_tmp = atom_typeid*g3<<2;\n"
"			cube [idx_000] = *(dockpars_fgrids + offset_cube_000 + mul_tmp);\n"
"			cube [idx_100] = *(dockpars_fgrids + offset_cube_100 + mul_tmp);\n"
"      			cube [idx_010] = *(dockpars_fgrids + offset_cube_010 + mul_tmp);\n"
"      			cube [idx_110] = *(dockpars_fgrids + offset_cube_110 + mul_tmp);\n"
"		       	cube [idx_001] = *(dockpars_fgrids + offset_cube_001 + mul_tmp);\n"
"		        cube [idx_101] = *(dockpars_fgrids + offset_cube_101 + mul_tmp);\n"
"		        cube [idx_011] = *(dockpars_fgrids + offset_cube_011 + mul_tmp);\n"
"		        cube [idx_111] = *(dockpars_fgrids + offset_cube_111 + mul_tmp);\n"
"\n"
"			// Vector in x-direction\n"
"			x10 = cube [idx_100] - cube [idx_000]; // z = 0\n"
"			x52 = cube [idx_110] - cube [idx_010]; // z = 0\n"
"			x43 = cube [idx_101] - cube [idx_001]; // z = 1\n"
"			x76 = cube [idx_111] - cube [idx_011]; // z = 1\n"
"			vx_z0 = (1.0f - dy) * x10 + dy * x52;     // z = 0\n"
"			vx_z1 = (1.0f - dy) * x43 + dy * x76;     // z = 1\n"
"			gradient_inter_x[atom_id] += q * ((1.0f - dz) * vx_z0 + dz * vx_z1);\n"
"\n"
"			// Vector in y-direction\n"
"			y20 = cube[idx_010] - cube [idx_000];	// z = 0\n"
"			y51 = cube[idx_110] - cube [idx_100];	// z = 0\n"
"			y63 = cube[idx_011] - cube [idx_001];	// z = 1\n"
"			y74 = cube[idx_111] - cube [idx_101];	// z = 1\n"
"			vy_z0 = (1.0f - dx) * y20 + dx * y51;	// z = 0\n"
"			vy_z1 = (1.0f - dx) * y63 + dx * y74;	// z = 1\n"
"			gradient_inter_y[atom_id] += q *((1.0f - dz) * vy_z0 + dz * vy_z1);\n"
"\n"
"			// Vectors in z-direction\n"
"			z30 = cube [idx_001] - cube [idx_000];	// y = 0\n"
"			z41 = cube [idx_101] - cube [idx_100];	// y = 0\n"
"			z62 = cube [idx_011] - cube [idx_010];	// y = 1 \n"
"			z75 = cube [idx_111] - cube [idx_110];	// y = 1\n"
"			vz_y0 = (1.0f - dx) * z30 + dx * z41;	// y = 0\n"
"			vz_y1 = (1.0f - dx) * z62 + dx * z75;	// y = 1\n"
"			gradient_inter_z[atom_id] += q *((1.0f - dy) * vz_y0 + dy * vz_y1);\n"
"\n"
"			//printf(\"%-15s %-3u %-10.8f %-10.8f %-10.8f %-10.8f %-10.8f %-10.8f\\n\", \"elec\", atom_id, vx_z0, vx_z1, vy_z0, vy_z1, vz_y0, vz_y1);\n"
"\n"
"			// -------------------------------------------------------------------\n"
"			// Calculating gradients (forces) corresponding to \n"
"			// \"dsol\" intermolecular energy\n"
"			// Derived from autodockdev/maps.py\n"
"			// -------------------------------------------------------------------\n"
"\n"
"			// Capturing desolvation values\n"
"			atom_typeid = dockpars_num_of_map_atypes+1;\n"
"\n"
"			mul_tmp = atom_typeid*g3<<2;\n"
"			cube [idx_000] = *(dockpars_fgrids + offset_cube_000 + mul_tmp);\n"
"			cube [idx_100] = *(dockpars_fgrids + offset_cube_100 + mul_tmp);\n"
"			cube [idx_010] = *(dockpars_fgrids + offset_cube_010 + mul_tmp);\n"
"			cube [idx_110] = *(dockpars_fgrids + offset_cube_110 + mul_tmp);\n"
"			cube [idx_001] = *(dockpars_fgrids + offset_cube_001 + mul_tmp);\n"
"			cube [idx_101] = *(dockpars_fgrids + offset_cube_101 + mul_tmp);\n"
"			cube [idx_011] = *(dockpars_fgrids + offset_cube_011 + mul_tmp);\n"
"			cube [idx_111] = *(dockpars_fgrids + offset_cube_111 + mul_tmp);\n"
"\n"
"			// Vector in x-direction\n"
"			x10 = cube [idx_100] - cube [idx_000]; // z = 0\n"
"			x52 = cube [idx_110] - cube [idx_010]; // z = 0\n"
"			x43 = cube [idx_101] - cube [idx_001]; // z = 1\n"
"			x76 = cube [idx_111] - cube [idx_011]; // z = 1\n"
"			vx_z0 = (1.0f - dy) * x10 + dy * x52;     // z = 0\n"
"			vx_z1 = (1.0f - dy) * x43 + dy * x76;     // z = 1\n"
"			gradient_inter_x[atom_id] += fabs(q) * ((1.0f - dz) * vx_z0 + dz * vx_z1);\n"
"\n"
"			// Vector in y-direction\n"
"			y20 = cube[idx_010] - cube [idx_000];	// z = 0\n"
"			y51 = cube[idx_110] - cube [idx_100];	// z = 0\n"
"			y63 = cube[idx_011] - cube [idx_001];	// z = 1\n"
"			y74 = cube[idx_111] - cube [idx_101];	// z = 1\n"
"			vy_z0 = (1.0f - dx) * y20 + dx * y51;	// z = 0\n"
"			vy_z1 = (1.0f - dx) * y63 + dx * y74;	// z = 1\n"
"			gradient_inter_y[atom_id] += fabs(q) *((1.0f - dz) * vy_z0 + dz * vy_z1);\n"
"\n"
"			// Vectors in z-direction\n"
"			z30 = cube [idx_001] - cube [idx_000];	// y = 0\n"
"			z41 = cube [idx_101] - cube [idx_100];	// y = 0\n"
"			z62 = cube [idx_011] - cube [idx_010];	// y = 1 \n"
"			z75 = cube [idx_111] - cube [idx_110];	// y = 1\n"
"			vz_y0 = (1.0f - dx) * z30 + dx * z41;	// y = 0\n"
"			vz_y1 = (1.0f - dx) * z62 + dx * z75;	// y = 1\n"
"			gradient_inter_z[atom_id] += fabs(q) *((1.0f - dy) * vz_y0 + dy * vz_y1);\n"
"\n"
"			//printf(\"%-15s %-3u %-10.8f %-10.8f %-10.8f %-10.8f %-10.8f %-10.8f\\n\", \"desol\", atom_id, vx_z0, vx_z1, vy_z0, vy_z1, vz_y0, vz_y1);\n"
"			// -------------------------------------------------------------------\n"
"		}\n"
"\n"
"	} // End atom_id for-loop (INTERMOLECULAR ENERGY)\n"
"\n"
"	// Inter- and intra-molecular energy calculation\n"
"	// are independent from each other, so NO barrier is needed here.\n"
"	// As these two require different operations,\n"
"	// they can be executed only sequentially on the GPU.\n"
"\n"
"	// ================================================\n"
"	// CALCULATING INTRAMOLECULAR GRADIENTS\n"
"	// ================================================\n"
"	for ( int contributor_counter = tidx;\n"
"	          contributor_counter < dockpars_num_of_intraE_contributors;\n"
"	          contributor_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		// Storing in a private variable\n"
"		// the gradient contribution of each contributing atomic pair\n"
"		float priv_gradient_per_intracontributor= 0.0f;\n"
"\n"
"		// Getting atom IDs\n"
"		uint atom1_id = kerconst_intracontrib->intraE_contributors_const[2*contributor_counter];\n"
"		uint atom2_id = kerconst_intracontrib->intraE_contributors_const[2*contributor_counter+1];\n"
"\n"
"		/*\n"
"		printf (\"%-5u %-5u %-5u\\n\", contributor_counter, atom1_id, atom2_id);\n"
"		*/\n"
"\n"
"		// Calculating vector components of vector going\n"
"		// from first atom's to second atom's coordinates\n"
"		float subx = calc_coords[atom1_id].x - calc_coords[atom2_id].x;\n"
"		float suby = calc_coords[atom1_id].y - calc_coords[atom2_id].y;\n"
"		float subz = calc_coords[atom1_id].z - calc_coords[atom2_id].z;\n"
"\n"
"		// Calculating atomic distance\n"
"		float dist = native_sqrt(subx*subx + suby*suby + subz*subz);\n"
"		float atomic_distance = dist*dockpars_grid_spacing;\n"
"\n"
"		// Getting type IDs\n"
"		uint atom1_typeid = kerconst_interintra->atom_types_const[atom1_id];\n"
"		uint atom2_typeid = kerconst_interintra->atom_types_const[atom2_id];\n"
"\n"
"		uint atom1_type_vdw_hb = kerconst_intra->atom_types_reqm_const [atom1_typeid];\n"
"	     	uint atom2_type_vdw_hb = kerconst_intra->atom_types_reqm_const [atom2_typeid];\n"
"		//printf (\"%-5u %-5u %-5u\\n\", contributor_counter, atom1_id, atom2_id);\n"
"\n"
"		ushort exps = kerconst_intra->VWpars_exp_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid];\n"
"		char m=(exps & 0xFF00)>>8;\n"
"		char n=(exps & 0xFF);\n"
"		// Getting optimum pair distance (opt_distance) from reqm and reqm_hbond\n"
"		float opt_distance = kerconst_intra->reqm_AB_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid];\n"
"\n"
"		// Getting smoothed distance\n"
"		// smoothed_distance = function(atomic_distance, opt_distance)\n"
"		float smoothed_distance;\n"
"		float delta_distance = 0.5f*dockpars_smooth;\n"
"\n"
"		if (atomic_distance <= (opt_distance - delta_distance)) {\n"
"			smoothed_distance = atomic_distance + delta_distance;\n"
"		}\n"
"		else if (atomic_distance < (opt_distance + delta_distance)) {\n"
"			smoothed_distance = opt_distance;\n"
"		}\n"
"		else { // else if (atomic_distance >= (opt_distance + delta_distance))\n"
"			smoothed_distance = atomic_distance - delta_distance;\n"
"		}\n"
"\n"
"		// Calculating gradient contributions\n"
"		// Cuttoff1: internuclear-distance at 8A only for vdw and hbond.\n"
"		if (atomic_distance < 8.0f)\n"
"		{\n"
"			// Calculating van der Waals / hydrogen bond term\n"
"			priv_gradient_per_intracontributor += native_divide (-(float)m*kerconst_intra->VWpars_AC_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],\n"
"			                                                      native_powr(smoothed_distance/*atomic_distance*/, m+1)\n"
"			                                                    );\n"
"\n"
"			priv_gradient_per_intracontributor += native_divide ((float)n*kerconst_intra->VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],\n"
"			                                                     native_powr(smoothed_distance/*atomic_distance*/, n+1)\n"
"			                                                    );\n"
"		} // if cuttoff1 - internuclear-distance at 8A\n"
"\n"
"		// Calculating energy contributions\n"
"		// Cuttoff2: internuclear-distance at 20.48A only for el and sol.\n"
"		if (atomic_distance < 20.48f)\n"
"		{\n"
"			if(atomic_distance<dockpars_elec_min_distance) atomic_distance=dockpars_elec_min_distance;\n"
"			// Calculating electrostatic term\n"
"			// http://www.wolframalpha.com/input/?i=1%2F(x*(A%2B(B%2F(1%2BK*exp(-h*B*x)))))\n"
"			float upper = DIEL_A*native_powr(native_exp(DIEL_B_TIMES_H*atomic_distance) + DIEL_K, 2) + (DIEL_B)*native_exp(DIEL_B_TIMES_H*atomic_distance)*(DIEL_B_TIMES_H_TIMES_K*atomic_distance + native_exp(DIEL_B_TIMES_H*atomic_distance) + DIEL_K);\n"
"			float lower = native_powr(atomic_distance, 2) * native_powr(DIEL_A * (native_exp(DIEL_B_TIMES_H*atomic_distance) + DIEL_K) + DIEL_B * native_exp(DIEL_B_TIMES_H*atomic_distance), 2);\n"
"\n"
"			priv_gradient_per_intracontributor +=  -dockpars_coeff_elec * kerconst_interintra->atom_charges_const[atom1_id] * kerconst_interintra->atom_charges_const[atom2_id] * native_divide (upper, lower);\n"
"\n"
"			// Calculating desolvation term\n"
"			priv_gradient_per_intracontributor += ((kerconst_intra->dspars_S_const[atom1_typeid] + dockpars_qasp*fabs(kerconst_interintra->atom_charges_const[atom1_id])) * kerconst_intra->dspars_V_const[atom2_typeid] +\n"
"			                                       (kerconst_intra->dspars_S_const[atom2_typeid] + dockpars_qasp*fabs(kerconst_interintra->atom_charges_const[atom2_id])) * kerconst_intra->dspars_V_const[atom1_typeid]\n"
"			                                      ) * dockpars_coeff_desolv * /*-0.07716049382716049*/ -0.077160f * atomic_distance * native_exp(/*-0.038580246913580245*/ -0.038580f *native_powr(atomic_distance, 2));\n"
"		} // if cuttoff2 - internuclear-distance at 20.48A\n"
"\n"
"		// ------------------------------------------------\n"
"		// Required only for flexrings\n"
"		// Checking if this is a CG-G0 atomic pair.\n"
"		// If so, then adding energy term (E = G * distance).\n"
"		// Initial specification required NON-SMOOTHED distance.\n"
"		// This interaction is evaluated at any distance,\n"
"		// so no cuttoffs considered here!\n"
"		if (((atom1_type_vdw_hb == ATYPE_CG_IDX) && (atom2_type_vdw_hb == ATYPE_G0_IDX)) ||\n"
"		    ((atom1_type_vdw_hb == ATYPE_G0_IDX) && (atom2_type_vdw_hb == ATYPE_CG_IDX)))\n"
"		{\n"
"			priv_gradient_per_intracontributor += G;\n"
"		}\n"
"		// ------------------------------------------------\n"
"\n"
"		// Decomposing \"priv_gradient_per_intracontributor\" \n"
"		// into the contribution of each atom of the pair.\n"
"		// Distances in Angstroms of vector that goes from \n"
"		// \"atom1_id\"-to-\"atom2_id\", therefore - subx, - suby, and - subz are used\n"
"		float subx_div_dist = native_divide(-subx, dist);\n"
"		float suby_div_dist = native_divide(-suby, dist);\n"
"		float subz_div_dist = native_divide(-subz, dist);\n"
"\n"
"		float priv_intra_gradient_x = priv_gradient_per_intracontributor * subx_div_dist;\n"
"		float priv_intra_gradient_y = priv_gradient_per_intracontributor * suby_div_dist;\n"
"		float priv_intra_gradient_z = priv_gradient_per_intracontributor * subz_div_dist;\n"
"		\n"
"		// Calculating gradients in xyz components.\n"
"		// Gradients for both atoms in a single contributor pair\n"
"		// have the same magnitude, but opposite directions\n"
"		atomicSub_g_f(&gradient_intra_x[atom1_id], priv_intra_gradient_x);\n"
"		atomicSub_g_f(&gradient_intra_y[atom1_id], priv_intra_gradient_y);\n"
"		atomicSub_g_f(&gradient_intra_z[atom1_id], priv_intra_gradient_z);\n"
"\n"
"		atomicAdd_g_f(&gradient_intra_x[atom2_id], priv_intra_gradient_x);\n"
"		atomicAdd_g_f(&gradient_intra_y[atom2_id], priv_intra_gradient_y);\n"
"		atomicAdd_g_f(&gradient_intra_z[atom2_id], priv_intra_gradient_z);\n"
"	} // End contributor_counter for-loop (INTRAMOLECULAR ENERGY)\n"
"	\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	\n"
"	// Accumulating inter- and intramolecular gradients\n"
"	for ( int atom_cnt = tidx;\n"
"	          atom_cnt < dockpars_num_of_atoms;\n"
"	          atom_cnt+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		// Grid gradients were calculated in the grid space,\n"
"		// so they have to be put back in Angstrom.\n"
"\n"
"		// Intramolecular gradients were already in Angstrom,\n"
"		// so no scaling for them is required.\n"
"		gradient_inter_x[atom_cnt] = native_divide(gradient_inter_x[atom_cnt], dockpars_grid_spacing);\n"
"		gradient_inter_y[atom_cnt] = native_divide(gradient_inter_y[atom_cnt], dockpars_grid_spacing);\n"
"		gradient_inter_z[atom_cnt] = native_divide(gradient_inter_z[atom_cnt], dockpars_grid_spacing);\n"
"\n"
"		#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"		if (atom_cnt == 0) {\n"
"			printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"			printf(\"%s\\n\", \"Gradients: inter and intra\");\n"
"			printf(\"%10s %13s %13s %13s %5s %13s %13s %13s\\n\", \"atom_id\", \"grad_intER.x\", \"grad_intER.y\", \"grad_intER.z\", \"|\", \"grad_intRA.x\", \"grad_intRA.y\", \"grad_intRA.z\");\n"
"		}\n"
"		printf(\"%10u %13.6f %13.6f %13.6f %5s %13.6f %13.6f %13.6f\\n\", atom_cnt, gradient_inter_x[atom_cnt], gradient_inter_y[atom_cnt], gradient_inter_z[atom_cnt], \"|\", gradient_intra_x[atom_cnt], gradient_intra_y[atom_cnt], gradient_intra_z[atom_cnt]);\n"
"		#endif\n"
"\n"
"		// Re-using \"gradient_inter_*\" for total gradient (inter+intra)\n"
"		gradient_inter_x[atom_cnt] += gradient_intra_x[atom_cnt];\n"
"		gradient_inter_y[atom_cnt] += gradient_intra_y[atom_cnt];\n"
"		gradient_inter_z[atom_cnt] += gradient_intra_z[atom_cnt];\n"
"\n"
"		//printf(\"%-15s %-5u %-10.8f %-10.8f %-10.8f\\n\", \"grad_grid\", atom_cnt, gradient_inter_x[atom_cnt], gradient_inter_y[atom_cnt], gradient_inter_z[atom_cnt]);\n"
"		//printf(\"%-15s %-5u %-10.8f %-10.8f %-10.8f\\n\", \"grad_intra\", atom_cnt, gradient_intra_x[atom_cnt], gradient_intra_y[atom_cnt], gradient_intra_z[atom_cnt]);\n"
"		//printf(\"%-15s %-5u %-10.8f %-10.8f %-10.8f\\n\", \"calc_coords\", atom_cnt, calc_coords_x[atom_cnt], calc_coords_y[atom_cnt], calc_coords_z[atom_cnt]);\n"
"\n"
"		#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"		if (atom_cnt == 0) {\n"
"			printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"			printf(\"%s\\n\", \"Gradients: total = inter + intra\");\n"
"			printf(\"%10s %13s %13s %13s\\n\", \"atom_id\", \"grad.x\", \"grad.y\", \"grad.z\");\n"
"		}\n"
"		printf(\"%10u %13.6f %13.6f %13.6f \\n\", atom_cnt, gradient_inter_x[atom_cnt], gradient_inter_y[atom_cnt], gradient_inter_z[atom_cnt]);\n"
"		#endif\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"\n"
"\n"
"	// ------------------------------------------\n"
"	// Obtaining translation-related gradients\n"
"	// ------------------------------------------\n"
"	if (tidx == 0) {\n"
"		for ( int lig_atom_id = 0;\n"
"		          lig_atom_id<dockpars_true_ligand_atoms;\n"
"		          lig_atom_id++)\n"
"		{\n"
"			// Re-using \"gradient_inter_*\" for total gradient (inter+intra)\n"
"			gradient_genotype[0] += gradient_inter_x[lig_atom_id]; // gradient for gene 0: gene x\n"
"			gradient_genotype[1] += gradient_inter_y[lig_atom_id]; // gradient for gene 1: gene y\n"
"			gradient_genotype[2] += gradient_inter_z[lig_atom_id]; // gradient for gene 2: gene z\n"
"		}\n"
"\n"
"		// Scaling gradient for translational genes as \n"
"		// their corresponding gradients were calculated in the space \n"
"		// where these genes are in Angstrom,\n"
"		// but AutoDock-GPU translational genes are within in grids\n"
"		gradient_genotype[0] *= dockpars_grid_spacing;\n"
"		gradient_genotype[1] *= dockpars_grid_spacing;\n"
"		gradient_genotype[2] *= dockpars_grid_spacing;\n"
"\n"
"		#if defined (PRINT_GRAD_TRANSLATION_GENES)\n"
"		printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"		printf(\"gradient_x:%f\\n\", gradient_genotype [0]);\n"
"		printf(\"gradient_y:%f\\n\", gradient_genotype [1]);\n"
"		printf(\"gradient_z:%f\\n\", gradient_genotype [2]);\n"
"		#endif\n"
"	}\n"
"\n"
"	// ------------------------------------------\n"
"	// Obtaining rotation-related gradients\n"
"	// ------------------------------------------ \n"
"				\n"
"	// Transform gradients_inter_{x|y|z} \n"
"	// into local_gradients[i] (with four quaternion genes)\n"
"	// Derived from autodockdev/motions.py/forces_to_delta_genes()\n"
"\n"
"	// Transform local_gradients[i] (with four quaternion genes)\n"
"	// into local_gradients[i] (with three Shoemake genes)\n"
"	// Derived from autodockdev/motions.py/_get_cube3_gradient()\n"
"	// ------------------------------------------\n"
"	if ((tidx == 1) | (NUM_OF_THREADS_PER_BLOCK<1)) {\n"
"		float3 torque_rot;\n"
"		torque_rot.x = 0.0f;\n"
"		torque_rot.y = 0.0f;\n"
"		torque_rot.z = 0.0f;\n"
"\n"
"		#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"		printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"		printf(\"%-20s %-10.6f %-10.6f %-10.6f\\n\", \"initial torque: \", torque_rot.x, torque_rot.y, torque_rot.z);\n"
"		#endif\n"
"\n"
"		// Declaring a variable to hold the center of rotation \n"
"		// In getparameters.cpp, it indicates \n"
"		// translation genes are in grid spacing (instead of Angstroms)\n"
"		float3 about;\n"
"		about.x = genotype[0];\n"
"		about.y = genotype[1];\n"
"		about.z = genotype[2];\n"
"	\n"
"		// Temporal variable to calculate translation differences.\n"
"		// They are converted back to Angstroms here\n"
"		float3 r;\n"
"			\n"
"		for ( int lig_atom_id = 0;\n"
"		          lig_atom_id<dockpars_true_ligand_atoms;\n"
"		          lig_atom_id++)\n"
"		{\n"
"			r.x = (calc_coords[lig_atom_id].x - about.x) * dockpars_grid_spacing;\n"
"			r.y = (calc_coords[lig_atom_id].y - about.y) * dockpars_grid_spacing;\n"
"			r.z = (calc_coords[lig_atom_id].z - about.z) * dockpars_grid_spacing;\n"
"\n"
"			// Re-using \"gradient_inter_*\" for total gradient (inter+intra)\n"
"			float3 force;\n"
"			force.x = gradient_inter_x[lig_atom_id];\n"
"			force.y = gradient_inter_y[lig_atom_id]; \n"
"			force.z = gradient_inter_z[lig_atom_id];\n"
"\n"
"			torque_rot += cross(r, force);\n"
"\n"
"			#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"#if 0\n"
"			printf(\"%-20s %-10u\\n\", \"contrib. of atom-id: \", lig_atom_id);\n"
"			printf(\"%-20s %-10.5f %-10.5f %-10.5f\\n\", \"r             : \", r.x, r.y, r.z);\n"
"			printf(\"%-20s %-10.5f %-10.5f %-10.5f\\n\", \"force         : \", force.x, force.y, force.z);\n"
"			printf(\"%-20s %-10.5f %-10.5f %-10.5f\\n\", \"partial torque: \", torque_rot.x, torque_rot.y, torque_rot.z);\n"
"			printf(\"\\n\");\n"
"#endif\n"
"			// This printing is similar to autodockdevpy\n"
"			if (lig_atom_id == 0) {\n"
"				printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"				printf(\"%s\\n\", \"Torque: atom-based accumulation of torque\");\n"
"				printf(\"%10s %10s %10s %10s %5s %12s %12s %12s %5s %11s %11s %11s\\n\", \"atom_id\", \"r.x\", \"r.y\", \"r.z\", \"|\", \"force.x\", \"force.y\", \"force.z\", \"|\", \"torque.x\", \"torque.y\", \"torque.z\");\n"
"			}\n"
"			printf(\"%10u %10.6f %10.6f %10.6f %5s %12.6f %12.6f %12.6f %5s %12.6f %12.6f %12.6f\\n\", lig_atom_id, r.x, r.y, r.z, \"|\", force.x, force.y, force.z, \"|\", torque_rot.x, torque_rot.y, torque_rot.z);\n"
"			//printf(\"%-10u %-10.6f %-10.6f %-10.6f %-10.6f %-10.6f %-10.6f\\n\", lig_atom_id, r.x, r.y, r.z, force.x, force.y, force.z);\n"
"			#endif\n"
"		}\n"
"\n"
"		#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"		printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"		printf(\"%-20s %-10.6f %-10.6f %-10.6f\\n\", \"final torque: \", torque_rot.x, torque_rot.y, torque_rot.z);\n"
"		#endif\n"
"\n"
"		// Derived from rotation.py/axisangle_to_q()\n"
"		// genes[3:7] = rotation.axisangle_to_q(torque, rad)\n"
"		float torque_length = native_sqrt(torque_rot.x*torque_rot.x+torque_rot.y*torque_rot.y+torque_rot.z*torque_rot.z);\n"
"		float orientation_scaling = orientation_scaling = (torque_length<INFINITESIMAL_RADIAN) ? 1.0f : torque_length * INV_INFINITESIMAL_RADIAN;\n"
"\n"
"		torque_rot *= (torque_length<INFINITESIMAL_RADIAN) ? 0.5f - native_divide(torque_length*torque_length,48.0f) : native_divide(SIN_HALF_INFINITESIMAL_RADIAN,torque_length);\n"
"		\n"
"		#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"		printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"		printf(\"%-20s %-10.6f\\n\", \"torque length: \", torque_length);\n"
"		#endif\n"
"\n"
"		// Finding the quaternion that performs\n"
"		// the infinitesimal rotation around torque axis\n"
"		float4 quat_torque;\n"
"		quat_torque.x = torque_rot.x;\n"
"		quat_torque.y = torque_rot.y;\n"
"		quat_torque.z = torque_rot.z;\n"
"		quat_torque.w = (torque_length<INFINITESIMAL_RADIAN) ? 1.0f-torque_length*torque_length*0.125f : COS_HALF_INFINITESIMAL_RADIAN;\n"
"\n"
"		#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"		printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"		printf(\"%-20s %-10.6f\\n\", \"INFINITESIMAL_RADIAN: \", INFINITESIMAL_RADIAN);\n"
"		printf(\"%-20s %-10.6f %-10.6f %-10.6f %-10.6f\\n\", \"quat_torque (w,x,y,z): \", quat_torque.w, quat_torque.x, quat_torque.y, quat_torque.z);\n"
"		#endif\n"
"\n"
"		// Converting quaternion gradients into orientation gradients \n"
"		// Derived from autodockdev/motion.py/_get_cube3_gradient\n"
"		#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"		printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"		printf(\"%-30s %-10.6f %-10.6f %-10.6f %-10.6f\\n\", \"current_q (w,x,y,z): \", genrot_unitvec.w, genrot_unitvec.x, genrot_unitvec.y, genrot_unitvec.z);\n"
"		#endif\n"
"\n"
"		// This is where we want to be in quaternion space\n"
"		// target_q = rotation.q_mult(q, current_q)\n"
"		float4 target_q = quaternion_multiply(quat_torque, genrot_unitvec);\n"
"\n"
"		#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"		printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"		printf(\"%-30s %-10.6f %-10.6f %-10.6f %-10.6f\\n\", \"target_q (w,x,y,z): \", target_q.w, target_q.x, target_q.y, target_q.z);\n"
"		#endif\n"
"\n"
"		// This is where we are in the orientation axis-angle space\n"
"		// Equivalent to \"current_oclacube\" in autodockdev/motions.py\n"
"		float current_phi      = fmod_pi2(PI_TIMES_2 + phi);\n"
"		float current_theta    = fmod_pi2(PI_TIMES_2 + theta);\n"
"		float current_rotangle = fmod_pi2(PI_TIMES_2 + genrotangle);\n"
"\n"
"		// This is where we want to be in the orientation axis-angle space\n"
"		float target_phi, target_theta, target_rotangle;\n"
"\n"
"		// target_oclacube = quaternion_to_oclacube(target_q, theta_larger_than_pi)\n"
"		// Derived from autodockdev/motions.py/quaternion_to_oclacube()\n"
"		// In our terms means quaternion_to_oclacube(target_q{w|x|y|z}, theta_larger_than_pi)\n"
"		target_rotangle = 2.0f * fast_acos(target_q.w); // = 2.0f * ang;\n"
"		float inv_sin_ang = native_rsqrt(1.0f-target_q.w*target_q.w); // = 1.0/native_sin(ang);\n"
"\n"
"		target_theta = PI_TIMES_2 + is_theta_gt_pi * fast_acos( target_q.z * inv_sin_ang );\n"
"		target_phi   = fmod_pi2((atan2( is_theta_gt_pi*target_q.y, is_theta_gt_pi*target_q.x) + PI_TIMES_2));\n"
"\n"
"		#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"		printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"		printf(\"%-30s %-10.6f %-10.6f %-10.6f\\n\", \"target_axisangle (1,2,3): \", target_phi, target_theta, target_rotangle);\n"
"		#endif\n"
"		\n"
"		// The infinitesimal rotation will produce an infinitesimal displacement\n"
"		// in shoemake space. This is to guarantee that the direction of\n"
"		// the displacement in shoemake space is not distorted.\n"
"		// The correct amount of displacement in shoemake space is obtained\n"
"		// by multiplying the infinitesimal displacement by shoemake_scaling:\n"
"		float grad_phi      = orientation_scaling * (fmod(target_phi 	 - current_phi 	    + PI_FLOAT, PI_TIMES_2) - PI_FLOAT);\n"
"		float grad_theta    = orientation_scaling * (fmod(target_theta    - current_theta    + PI_FLOAT, PI_TIMES_2) - PI_FLOAT);\n"
"		float grad_rotangle = orientation_scaling * (fmod(target_rotangle - current_rotangle + PI_FLOAT, PI_TIMES_2) - PI_FLOAT);\n"
"\n"
"		float rot_angle_corr = 4.0f * sin_half_rotangle * sin_half_rotangle; // 4*sin(rotangle/2)^2\n"
"		\n"
"		// Setting gradient rotation-related genotypes in cube\n"
"		// Multiplicating by DEG_TO_RAD is to make it uniform to DEG (see torsion gradients)\n"
"		gradient_genotype[3] = grad_phi * sin_theta * sin_theta * rot_angle_corr * DEG_TO_RAD;\n"
"		gradient_genotype[4] = grad_theta * rot_angle_corr * DEG_TO_RAD;\n"
"		gradient_genotype[5] = grad_rotangle * DEG_TO_RAD;\n"
"		#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"		printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"		printf(\"%-30s \\n\", \"grad_axisangle (1,2,3) - after empirical scaling: \");\n"
"		printf(\"%-13s %-13s %-13s \\n\", \"grad_phi\", \"grad_theta\", \"grad_rotangle\");\n"
"		printf(\"%-13.6f %-13.6f %-13.6f\\n\", gradient_genotype[3], gradient_genotype[4], gradient_genotype[5]);\n"
"		#endif\n"
"	}\n"
"\n"
"	// ------------------------------------------\n"
"	// Obtaining torsion-related gradients\n"
"	// ------------------------------------------\n"
"\n"
"	for ( int rotbond_id = tidx;\n"
"	          rotbond_id < dockpars_num_of_genes-6;\n"
"	          rotbond_id +=NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		#if defined (PRINT_GRAD_TORSION_GENES)\n"
"		if (rotbond_id == 0) {\n"
"			printf(\"\\n%s\\n\", \"NOTE: torsion gradients are calculated by many work-items\");\n"
"		}\n"
"		#endif\n"
"		// Querying ids of atoms belonging to the rotatable bond in question\n"
"		int atom1_id = rotbonds_const[2*rotbond_id];\n"
"		int atom2_id = rotbonds_const[2*rotbond_id+1];\n"
"\n"
"		float3 atomRef_coords;\n"
"		atomRef_coords.x = calc_coords[atom1_id].x;\n"
"		atomRef_coords.y = calc_coords[atom1_id].y;\n"
"		atomRef_coords.z = calc_coords[atom1_id].z;\n"
"\n"
"		#if defined (PRINT_GRAD_TORSION_GENES)\n"
"		printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"		printf(\"%-5s %3u \\n\\t %-5s %3i \\n\\t %-5s %3i\\n\", \"gene: \", (rotbond_id+6), \"atom1: \", atom1_id, \"atom2: \", atom2_id);\n"
"		#endif\n"
"\n"
"		float3 rotation_unitvec;\n"
"		/*\n"
"		rotation_unitvec.x = kerconst_conform->rotbonds_unit_vectors_const[3*rotbond_id];\n"
"		rotation_unitvec.y = kerconst_conform->rotbonds_unit_vectors_const[3*rotbond_id+1];\n"
"		rotation_unitvec.z = kerconst_conform->rotbonds_unit_vectors_const[3*rotbond_id+2];\n"
"		*/\n"
"		rotation_unitvec.x = calc_coords[atom2_id].x - calc_coords[atom1_id].x;\n"
"		rotation_unitvec.y = calc_coords[atom2_id].y - calc_coords[atom1_id].y;\n"
"		rotation_unitvec.z = calc_coords[atom2_id].z - calc_coords[atom1_id].z;\n"
"		rotation_unitvec = fast_normalize(rotation_unitvec);\n"
"\n"
"		#if defined (PRINT_GRAD_TORSION_GENES)\n"
"		printf(\"\\n\");\n"
"		printf(\"%-15s \\n\\t %-10.6f %-10.6f %-10.6f\\n\", \"unitvec: \", rotation_unitvec.x, rotation_unitvec.y, rotation_unitvec.z);\n"
"		#endif\n"
"\n"
"		// Torque of torsions\n"
"		float3 torque_tor;\n"
"		torque_tor.x = 0.0f;\n"
"		torque_tor.y = 0.0f;\n"
"		torque_tor.z = 0.0f;\n"
"		// Iterating over each ligand atom that rotates \n"
"		// if the bond in question rotates\n"
"		for ( int rotable_atom_cnt = 0;\n"
"		          rotable_atom_cnt<num_rotating_atoms_per_rotbond_const[rotbond_id];\n"
"		          rotable_atom_cnt++)\n"
"		{\n"
"			uint lig_atom_id = rotbonds_atoms_const[MAX_NUM_OF_ATOMS*rotbond_id + rotable_atom_cnt];\n"
"			// Calculating torque on point \"A\"\n"
"			// (could be any other point \"B\" along the rotation axis)\n"
"			float3 atom_coords;\n"
"			atom_coords.x = calc_coords[lig_atom_id].x;\n"
"			atom_coords.y = calc_coords[lig_atom_id].y;\n"
"			atom_coords.z = calc_coords[lig_atom_id].z;\n"
"			// Temporal variable to calculate translation differences.\n"
"			// They are converted back to Angstroms here\n"
"			float3 r;\n"
"			r.x = (atom_coords.x - atomRef_coords.x) * dockpars_grid_spacing;\n"
"			r.y = (atom_coords.y - atomRef_coords.y) * dockpars_grid_spacing;\n"
"			r.z = (atom_coords.z - atomRef_coords.z) * dockpars_grid_spacing;\n"
"\n"
"			// Re-using \"gradient_inter_*\" for total gradient (inter+intra)\n"
"			float3 atom_force;\n"
"			atom_force.x = gradient_inter_x[lig_atom_id];\n"
"			atom_force.y = gradient_inter_y[lig_atom_id];\n"
"			atom_force.z = gradient_inter_z[lig_atom_id];\n"
"			torque_tor += cross(r, atom_force);\n"
"			#if defined (PRINT_GRAD_TORSION_GENES)\n"
"			if (rotable_atom_cnt == 0) {\n"
"				printf(\"\\n %-30s %3i\\n\", \"contributor for gene : \", (rotbond_id+6));\n"
"			}\n"
"			//printf(\"%-15s %-10u\\n\", \"rotable_atom_cnt: \", rotable_atom_cnt);\n"
"			//printf(\"%-15s %-10u\\n\", \"atom_id: \", lig_atom_id);\n"
"			printf(\"\\t %-15s %-10.6f %-10.6f %-10.6f \\t %-15s %-10.6f %-10.6f %-10.6f\\n\", \"atom_coords: \", atom_coords.x, atom_coords.y, atom_coords.z, \"atom_force: \", atom_force.x, atom_force.y, atom_force.z);\n"
"			//printf(\"%-15s %-10.6f %-10.6f %-10.6f\\n\", \"r: \", r.x, r.y, r.z);\n"
"			//printf(\"%-15s %-10.6f %-10.6f %-10.6f\\n\", \"atom_force: \", atom_force.x, atom_force.y, atom_force.z);\n"
"			//printf(\"%-15s %-10.6f %-10.6f %-10.6f\\n\", \"torque_tor: \", torque_tor.x, torque_tor.y, torque_tor.z);\n"
"			#endif\n"
"\n"
"		}\n"
"		#if defined (PRINT_GRAD_TORSION_GENES)\n"
"		printf(\"\\n\");\n"
"		#endif\n"
"\n"
"		// Projecting torque on rotation axis\n"
"		float torque_on_axis = dot(rotation_unitvec, torque_tor);\n"
"\n"
"		// Assignment of gene-based gradient\n"
"		gradient_genotype[rotbond_id+6] = torque_on_axis * DEG_TO_RAD /*(M_PI / 180.0f)*/;\n"
"\n"
"		#if defined (PRINT_GRAD_TORSION_GENES)\n"
"		printf(\"gradient_torsion [%u] :%f\\n\", rotbond_id+6, gradient_genotype [rotbond_id+6]);\n"
"		#endif\n"
"		\n"
"	} // End of iterations over rotatable bonds\n"
"	//----------------------------------\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	#if defined (CONVERT_INTO_ANGSTROM_RADIAN)\n"
"	for ( int gene_cnt = tidx;\n"
"	          gene_cnt < dockpars_num_of_genes;\n"
"	          gene_cnt+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		if (gene_cnt > 2) {\n"
"			gradient_genotype[gene_cnt] *= dockpars_grid_spacing * dockpars_grid_spacing * SCFACTOR_ANGSTROM_RADIAN;\n"
"		}\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	#endif\n"
"}\n"
"/*\n"
"\n"
"AutoDock-GPU, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"For some of the code, Copyright (C) 2019 Computational Structural Biology Center, the Scripps Research Institute.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This library is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU Lesser General Public\n"
"License as published by the Free Software Foundation; either\n"
"version 2.1 of the License, or (at your option) any later version.\n"
"\n"
"This library is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"Lesser General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU Lesser General Public\n"
"License along with this library; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n"
"\n"
"*/\n"
"\n"
"#ifndef FLOAT_GRADIENTS\n"
"#define TERMBITS         10\n"
"#define MAXTERM          ((float)(1 << (31 - TERMBITS - 8))) // 2^(31 - 10 - 8) = 2^13 = 8192\n"
"#define TERMSCALE        ((float)(1 << TERMBITS)) // 2^10 = 1024\n"
"#define ONEOVERTERMSCALE (1.0f / TERMSCALE) // 1 / 1024 = 0.000977\n"
"// inspired by: https://streamhpc.com/blog/2014-11-07/opencl-integer-rounding-c/\n"
"int float2int_round (float number)\n"
"{\n"
"   int addsub = (int)((number < 0.0f) - (number > 0.0f)); // +1 for number < 0 (round up, i.e. 1.5 -> 2.0), -1 for number > 0 (round down, i.e. -1.5 -> -2.0)\n"
"   return ((int)(number+0.5f*addsub));\n"
"}\n"
"#endif\n"
"\n"
"// Enable restoring map gradient\n"
"// Currently, this is not a good idea\n"
"// #define RESTORING_MAP_GRADIENT\n"
"\n"
"// IMPORTANT: the code of gradient calculation was the initial template.\n"
"// Then, statements corresponding to enery calculations were added gradually.\n"
"// The latter can be distinguised this way: they are place within lines without indentation.\n"
"\n"
"void gpu_calc_energrad(\n"
"                             int    dockpars_rotbondlist_length,\n"
"                             int    dockpars_num_of_atoms,\n"
"                             int    dockpars_true_ligand_atoms,\n"
"                             int    dockpars_gridsize_x,\n"
"                             int    dockpars_gridsize_y,\n"
"                             int    dockpars_gridsize_z,\n"
"                                                                         // g1 = gridsize_x\n"
"                             uint   dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"                             uint   dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"              __global const float* restrict dockpars_fgrids, // This is too large to be allocated in __constant\n"
"                             int    dockpars_num_of_atypes,\n"
"                             int    dockpars_num_of_map_atypes,\n"
"                             int    dockpars_num_of_intraE_contributors,\n"
"                             float  dockpars_grid_spacing,\n"
"                             float  dockpars_coeff_elec,\n"
"                             float  dockpars_elec_min_distance,\n"
"                             float  dockpars_qasp,\n"
"                             float  dockpars_coeff_desolv,\n"
"                             float  dockpars_smooth,\n"
"\n"
"                             // Some OpenCL compilers don't allow declaring\n"
"                             // local variables within non-kernel functions.\n"
"                             // These local variables must be declared in a kernel,\n"
"                             // and then passed to non-kernel functions.\n"
"                     __local float* genotype,\n"
"                     __local float* energy,\n"
"                     __local int*   run_id,\n"
"\n"
"                     __local float4* calc_coords,\n"
"                     __local float* partial_energies,\n"
"#if defined (DEBUG_ENERGY_KERNEL)\n"
"                     __local float* partial_interE,\n"
"                     __local float* partial_intraE,\n"
"#endif\n"
"            __constant       kernelconstant_interintra*   kerconst_interintra,\n"
"              __global const kernelconstant_intracontrib* kerconst_intracontrib,\n"
"            __constant       kernelconstant_intra*        kerconst_intra,\n"
"            __constant       kernelconstant_rotlist*      kerconst_rotlist,\n"
"            __constant       kernelconstant_conform*      kerconst_conform,\n"
"\n"
"            __constant       int*   rotbonds_const,\n"
"              __global const int*   rotbonds_atoms_const,\n"
"            __constant int*         num_rotating_atoms_per_rotbond_const,\n"
"\n"
"                             int    dockpars_num_of_genes,\n"
"#ifdef FLOAT_GRADIENTS\n"
"                     __local float* gradient_x,\n"
"                     __local float* gradient_y,\n"
"                     __local float* gradient_z,\n"
"#else\n"
"                     __local int*   gradient_x,\n"
"                     __local int*   gradient_y,\n"
"                     __local int*   gradient_z,\n"
"#endif\n"
"                     __local float* accumulator_x,\n"
"                     __local float* accumulator_y,\n"
"                     __local float* accumulator_z,\n"
"                     __local float* gradient_genotype\n"
"                      )\n"
"{\n"
"	int tidx = get_local_id(0);\n"
"	partial_energies[tidx] = 0.0f;\n"
"#if defined (DEBUG_ENERGY_KERNEL)\n"
"	partial_interE[tidx] = 0.0f;\n"
"	partial_intraE[tidx] = 0.0f;\n"
"#endif\n"
"\n"
"	// Initializing gradients (forces) \n"
"	// Derived from autodockdev/maps.py\n"
"	for ( int atom_id = tidx;\n"
"	          atom_id < dockpars_num_of_atoms;\n"
"	          atom_id+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		// Initialize coordinates\n"
"		calc_coords[atom_id] = (float4)(kerconst_conform->ref_coords_const[3*atom_id],\n"
"		                                kerconst_conform->ref_coords_const[3*atom_id+1],\n"
"		                                kerconst_conform->ref_coords_const[3*atom_id+2],0);\n"
"		// Integer gradients\n"
"		gradient_x[atom_id] = 0;\n"
"		gradient_y[atom_id] = 0;\n"
"		gradient_z[atom_id] = 0;\n"
"	}\n"
"\n"
"	// Initializing gradient genotypes\n"
"	for ( int gene_cnt = tidx;\n"
"	          gene_cnt < dockpars_num_of_genes;\n"
"	          gene_cnt+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		gradient_genotype[gene_cnt] = 0.0f;\n"
"	}\n"
"\n"
"	// General rotation moving vector\n"
"	float4 genrot_movingvec;\n"
"\n"
"	// Convert orientation genes from sex. to radians\n"
"	float phi         = genotype[3] * DEG_TO_RAD;\n"
"	float theta       = genotype[4] * DEG_TO_RAD;\n"
"	float genrotangle = genotype[5] * DEG_TO_RAD;\n"
"\n"
"	float4 genrot_unitvec;\n"
"	float is_theta_gt_pi, sin_half_rotangle, sin_theta;\n"
"	if(dockpars_true_ligand_atoms){\n"
"		genrot_movingvec.x = genotype[0];\n"
"		genrot_movingvec.y = genotype[1];\n"
"		genrot_movingvec.z = genotype[2];\n"
"		genrot_movingvec.w = 0.0f;\n"
"		sin_theta = native_sin(theta);\n"
"		float cos_theta = native_cos(theta);\n"
"		sin_half_rotangle = native_sin(genrotangle*0.5f);\n"
"		genrot_unitvec.x = sin_half_rotangle*sin_theta*native_cos(phi);\n"
"		genrot_unitvec.y = sin_half_rotangle*sin_theta*native_sin(phi);\n"
"		genrot_unitvec.z = sin_half_rotangle*cos_theta;\n"
"		genrot_unitvec.w = native_cos(genrotangle*0.5f);\n"
"		is_theta_gt_pi = 1.0f-2.0f*(float)(sin_theta < 0.0f);\n"
"	}\n"
"\n"
"	uint g1 = dockpars_gridsize_x;\n"
"	uint g2 = dockpars_gridsize_x_times_y;\n"
"	uint g3 = dockpars_gridsize_x_times_y_times_z;\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// ================================================\n"
"	// CALCULATING ATOMIC POSITIONS AFTER ROTATIONS\n"
"	// ================================================\n"
"	for ( int rotation_counter = tidx;\n"
"	          rotation_counter < dockpars_rotbondlist_length;\n"
"	          rotation_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		int rotation_list_element = kerconst_rotlist->rotlist_const[rotation_counter];\n"
"		if ((rotation_list_element & RLIST_DUMMY_MASK) == 0) // If not dummy rotation\n"
"		{\n"
"			int atom_id = rotation_list_element & RLIST_ATOMID_MASK;\n"
"			// Capturing atom coordinates\n"
"			float4 atom_to_rotate = calc_coords[atom_id];\n"
"			// initialize with general rotation values\n"
"			float4 rotation_unitvec;\n"
"			float4 rotation_movingvec;\n"
"			if (atom_id < dockpars_true_ligand_atoms){\n"
"				rotation_unitvec = genrot_unitvec;\n"
"				rotation_movingvec = genrot_movingvec;\n"
"			} else{\n"
"				rotation_unitvec.x = 0.0f; rotation_unitvec.y = 0.0f; rotation_unitvec.z = 0.0f;\n"
"				rotation_unitvec.w = 1.0f;\n"
"				rotation_movingvec.x = 0.0f; rotation_movingvec.y = 0.0f; rotation_movingvec.z = 0.0f;\n"
"				rotation_movingvec.w = 0.0f;\n"
"			}\n"
"			if ((rotation_list_element & RLIST_GENROT_MASK) == 0) // If rotating around rotatable bond\n"
"			{\n"
"				uint rotbond_id = (rotation_list_element & RLIST_RBONDID_MASK) >> RLIST_RBONDID_SHIFT;\n"
"				float rotation_angle = genotype[6+rotbond_id]*DEG_TO_RAD*0.5f;\n"
"				float s = native_sin(rotation_angle);\n"
"				rotation_unitvec = (float4)(s*kerconst_conform->rotbonds_unit_vectors_const[3*rotbond_id],\n"
"							    s*kerconst_conform->rotbonds_unit_vectors_const[3*rotbond_id+1],\n"
"							    s*kerconst_conform->rotbonds_unit_vectors_const[3*rotbond_id+2],\n"
"							    native_cos(rotation_angle));\n"
"				rotation_movingvec = (float4)(kerconst_conform->rotbonds_moving_vectors_const[3*rotbond_id],\n"
"							      kerconst_conform->rotbonds_moving_vectors_const[3*rotbond_id+1],\n"
"							      kerconst_conform->rotbonds_moving_vectors_const[3*rotbond_id+2],0.0f);\n"
"				// Performing additionally the first movement which\n"
"				// is needed only if rotating around rotatable bond\n"
"				atom_to_rotate -= rotation_movingvec;\n"
"			}\n"
"			// Performing rotation and final movement\n"
"			calc_coords[atom_id] = quaternion_rotate(atom_to_rotate,rotation_unitvec) + rotation_movingvec;\n"
"		} // End if-statement not dummy rotation\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"	} // End rotation_counter for-loop\n"
"\n"
"	// ================================================\n"
"	// CALCULATING INTERMOLECULAR GRADIENTS\n"
"	// ================================================\n"
"	float inv_grid_spacing = native_divide(1.0f,dockpars_grid_spacing);\n"
"	float weights[8];\n"
"	float cube[8];\n"
"	for ( int atom_id = tidx;\n"
"	          atom_id < dockpars_num_of_atoms;\n"
"	          atom_id+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		if (kerconst_interintra->ignore_inter_const[atom_id]>0) // first two atoms of a flex res are to be ignored here\n"
"			continue;\n"
"		float x = calc_coords[atom_id].x;\n"
"		float y = calc_coords[atom_id].y;\n"
"		float z = calc_coords[atom_id].z;\n"
"		float q = kerconst_interintra->atom_charges_const[atom_id];\n"
"		uint atom_typeid = kerconst_interintra->atom_types_map_const[atom_id];\n"
"\n"
"		if ((x < 0) || (y < 0) || (z < 0) || (x >= dockpars_gridsize_x-1)\n"
"		                                  || (y >= dockpars_gridsize_y-1)\n"
"		                                  || (z >= dockpars_gridsize_z-1)){\n"
"#ifdef RESTORING_MAP_GRADIENT\n"
"			x -= 0.5f * dockpars_gridsize_x;\n"
"			y -= 0.5f * dockpars_gridsize_y;\n"
"			z -= 0.5f * dockpars_gridsize_z;\n"
"			partial_energies[tidx] += 21.0f * (x*x+y*y+z*z); //100000.0f;\n"
"#else\n"
"			partial_energies[tidx] += 16777216.0f; //100000.0f;\n"
"#endif\n"
"			#if defined (DEBUG_ENERGY_KERNEL)\n"
"			partial_interE[tidx] += 21.0f * (x*x+y*y+z*z);\n"
"			#endif\n"
"#ifdef RESTORING_MAP_GRADIENT\n"
"			// Setting gradients (forces) penalties.\n"
"			// The idea here is to push the offending\n"
"			// molecule towards the center\n"
"			#ifdef FLOAT_GRADIENTS\n"
"			gradient_x[atom_id] += 42.0f * x * inv_grid_spacing;\n"
"			gradient_y[atom_id] += 42.0f * y * inv_grid_spacing;\n"
"			gradient_z[atom_id] += 42.0f * z * inv_grid_spacing;\n"
"			#else\n"
"			gradient_x[atom_id] += float2int_round( TERMSCALE * 42.0f * x * inv_grid_spacing );\n"
"			gradient_y[atom_id] += float2int_round( TERMSCALE * 42.0f * y * inv_grid_spacing );\n"
"			gradient_z[atom_id] += float2int_round( TERMSCALE * 42.0f * z * inv_grid_spacing );\n"
"			#endif // FLOAT_GRADIENTS\n"
"#else\n"
"			#ifdef FLOAT_GRADIENTS\n"
"			gradient_x[atom_id] += 16777216.0f;\n"
"			gradient_y[atom_id] += 16777216.0f;\n"
"			gradient_z[atom_id] += 16777216.0f;\n"
"			#else\n"
"			gradient_x[atom_id] += 16777216;\n"
"			gradient_y[atom_id] += 16777216;\n"
"			gradient_z[atom_id] += 16777216;\n"
"			#endif // FLOAT_GRADIENTS\n"
"#endif\n"
"			continue;\n"
"		}\n"
"		// Getting coordinates\n"
"		int x_low  = floor(x);\n"
"		int y_low  = floor(y);\n"
"		int z_low  = floor(z);\n"
"\n"
"		// Grid value at 000\n"
"		__global const float* grid_value_000 = dockpars_fgrids + ((ulong)(x_low  + y_low*g1  + z_low*g2)<<2);\n"
"\n"
"		float dx = x - x_low;\n"
"		float omdx = 1.0f - dx;\n"
"		float dy = y - y_low;\n"
"		float omdy = 1.0f - dy;\n"
"		float dz = z - z_low;\n"
"		float omdz = 1.0f - dz;\n"
"\n"
"		// Calculating interpolation weights\n"
"		weights [idx_000] = omdx*omdy*omdz;\n"
"		weights [idx_010] = omdx*dy*omdz;\n"
"		weights [idx_001] = omdx*omdy*dz;\n"
"		weights [idx_011] = omdx*dy*dz;\n"
"		weights [idx_100] = dx*omdy*omdz;\n"
"		weights [idx_110] = dx*dy*omdz;\n"
"		weights [idx_101] = dx*omdy*dz;\n"
"		weights [idx_111] = dx*dy*dz;\n"
"\n"
"		ulong mul_tmp = atom_typeid*g3<<2;\n"
"		cube[0] = *(grid_value_000+mul_tmp+0);\n"
"		cube[1] = *(grid_value_000+mul_tmp+1);\n"
"		cube[2] = *(grid_value_000+mul_tmp+2);\n"
"		cube[3] = *(grid_value_000+mul_tmp+3);\n"
"		cube[4] = *(grid_value_000+mul_tmp+4);\n"
"		cube[5] = *(grid_value_000+mul_tmp+5);\n"
"		cube[6] = *(grid_value_000+mul_tmp+6);\n"
"		cube[7] = *(grid_value_000+mul_tmp+7);\n"
"		// Calculating affinity energy\n"
"		partial_energies[tidx] += cube[0]*weights[0] + cube[1]*weights[1] + cube[2]*weights[2] + cube[3]*weights[3] + cube[4]*weights[4] + cube[5]*weights[5] + cube[6]*weights[6] + cube[7]*weights[7];\n"
"		#if defined (DEBUG_ENERGY_KERNEL)\n"
"		partial_interE[tidx] += cube[0]*weights[0] + cube[1]*weights[1] + cube[2]*weights[2] + cube[3]*weights[3] + cube[4]*weights[4] + cube[5]*weights[5] + cube[6]*weights[6] + cube[7]*weights[7];\n"
"		#endif\n"
"		// -------------------------------------------------------------------\n"
"		// Deltas dx, dy, dz are already normalized \n"
"		// (by host/src/getparameters.cpp) in AutoDock-GPU.\n"
"		// The correspondance between vertices in xyz axes is:\n"
"		// 0, 1, 2, 3, 4, 5, 6, 7  and  000, 100, 010, 001, 101, 110, 011, 111\n"
"		// -------------------------------------------------------------------\n"
"		/*\n"
"		    deltas: (x-x0)/(x1-x0), (y-y0...\n"
"		    vertices: (000, 100, 010, 001, 101, 110, 011, 111)        \n"
"		          Z\n"
"		          '\n"
"		          3 - - - - 6\n"
"		         /.        /|\n"
"		        4 - - - - 7 |\n"
"		        | '       | |\n"
"		        | 0 - - - + 2 -- Y\n"
"		        '/        |/\n"
"		        1 - - - - 5\n"
"		       /\n"
"		      X\n"
"		*/\n"
"\n"
"		// -------------------------------------------------------------------\n"
"		// Calculating gradients (forces) corresponding to \n"
"		// \"atype\" intermolecular energy\n"
"		// Derived from autodockdev/maps.py\n"
"		// -------------------------------------------------------------------\n"
"\n"
"		// Vector in x-direction\n"
"/*		x10 = cube [idx_100] - cube [idx_000]; // z = 0\n"
"		x52 = cube [idx_110] - cube [idx_010]; // z = 0\n"
"		x43 = cube [idx_101] - cube [idx_001]; // z = 1\n"
"		x76 = cube [idx_111] - cube [idx_011]; // z = 1\n"
"		vx_z0 = omdy * x10 + dy * x52;     // z = 0\n"
"		vx_z1 = omdy * x43 + dy * x76;     // z = 1\n"
"		gradient_inter_x[atom_id] += omdz * vx_z0 + dz * vx_z1;\n"
"\n"
"		// AT - reduced to two variables:\n"
"		vx_z0 = omdy * (cube [idx_100] - cube [idx_000]) + dy * (cube [idx_110] - cube [idx_010]);     // z = 0\n"
"		vx_z1 = omdy * (cube [idx_101] - cube [idx_001]) + dy * (cube [idx_111] - cube [idx_011]);     // z = 1 */\n"
"\n"
"		// AT - all in one go with no intermediate variables (following calcs are similar)\n"
"		// Vector in x-direction\n"
"		float gx = (omdz * (omdy * (cube [idx_100] - cube [idx_000]) + dy * (cube [idx_110] - cube [idx_010])) +\n"
"		              dz * (omdy * (cube [idx_101] - cube [idx_001]) + dy * (cube [idx_111] - cube [idx_011]))) * inv_grid_spacing;\n"
"		// Vector in y-direction\n"
"		float gy = (omdz * (omdx * (cube [idx_010] - cube [idx_000]) + dx * (cube [idx_110] - cube [idx_100])) +\n"
"		              dz * (omdx * (cube [idx_011] - cube [idx_001]) + dx * (cube [idx_111] - cube [idx_101]))) * inv_grid_spacing;\n"
"		// Vectors in z-direction\n"
"		float gz = (omdy * (omdx * (cube [idx_001] - cube [idx_000]) + dx * (cube [idx_101] - cube [idx_100])) +\n"
"		              dy * (omdx * (cube [idx_011] - cube [idx_010]) + dx * (cube [idx_111] - cube [idx_110]))) * inv_grid_spacing;\n"
"		// -------------------------------------------------------------------\n"
"		// Calculating gradients (forces) corresponding to \n"
"		// \"elec\" intermolecular energy\n"
"		// Derived from autodockdev/maps.py\n"
"		// -------------------------------------------------------------------\n"
"\n"
"		// Capturing electrostatic values\n"
"		atom_typeid = dockpars_num_of_map_atypes;\n"
"\n"
"		mul_tmp = atom_typeid*g3<<2; // different atom type id to get charge IA\n"
"		cube[0] = *(grid_value_000+mul_tmp+0);\n"
"		cube[1] = *(grid_value_000+mul_tmp+1);\n"
"		cube[2] = *(grid_value_000+mul_tmp+2);\n"
"		cube[3] = *(grid_value_000+mul_tmp+3);\n"
"		cube[4] = *(grid_value_000+mul_tmp+4);\n"
"		cube[5] = *(grid_value_000+mul_tmp+5);\n"
"		cube[6] = *(grid_value_000+mul_tmp+6);\n"
"		cube[7] = *(grid_value_000+mul_tmp+7);\n"
"\n"
"		// Calculating affinity energy\n"
"		partial_energies[tidx] += q * (cube[0]*weights[0] + cube[1]*weights[1] + cube[2]*weights[2] + cube[3]*weights[3] + cube[4]*weights[4] + cube[5]*weights[5] + cube[6]*weights[6] + cube[7]*weights[7]);\n"
"		#if defined (DEBUG_ENERGY_KERNEL)\n"
"		partial_interE[tidx] += q *(cube[0]*weights[0] + cube[1]*weights[1] + cube[2]*weights[2] + cube[3]*weights[3] + cube[4]*weights[4] + cube[5]*weights[5] + cube[6]*weights[6] + cube[7]*weights[7]);\n"
"		#endif\n"
"\n"
"		float qg = q*inv_grid_spacing;\n"
"		// Vector in x-direction\n"
"		gx += qg * ( omdz * (omdy * (cube [idx_100] - cube [idx_000]) + dy * (cube [idx_110] - cube [idx_010])) +\n"
"		               dz * (omdy * (cube [idx_101] - cube [idx_001]) + dy * (cube [idx_111] - cube [idx_011])));\n"
"		// Vector in y-direction\n"
"		gy += qg * ( omdz * (omdx * (cube [idx_010] - cube [idx_000]) + dx * (cube [idx_110] - cube [idx_100])) +\n"
"		               dz * (omdx * (cube [idx_011] - cube [idx_001]) + dx * (cube [idx_111] - cube [idx_101])));\n"
"		// Vectors in z-direction\n"
"		gz += qg * ( omdy * (omdx * (cube [idx_001] - cube [idx_000]) + dx * (cube [idx_101] - cube [idx_100])) +\n"
"		               dy * (omdx * (cube [idx_011] - cube [idx_010]) + dx * (cube [idx_111] - cube [idx_110])));\n"
"		// -------------------------------------------------------------------\n"
"		// Calculating gradients (forces) corresponding to \n"
"		// \"dsol\" intermolecular energy\n"
"		// Derived from autodockdev/maps.py\n"
"		// -------------------------------------------------------------------\n"
"		// Need only magnitude of charge from here on down\n"
"		q = fabs(q);\n"
"		// Capturing desolvation values (atom_typeid+1 compared to above => mul_tmp + g3*4)\n"
"		mul_tmp += g3<<2;\n"
"		cube[0] = *(grid_value_000+mul_tmp+0);\n"
"		cube[1] = *(grid_value_000+mul_tmp+1);\n"
"		cube[2] = *(grid_value_000+mul_tmp+2);\n"
"		cube[3] = *(grid_value_000+mul_tmp+3);\n"
"		cube[4] = *(grid_value_000+mul_tmp+4);\n"
"		cube[5] = *(grid_value_000+mul_tmp+5);\n"
"		cube[6] = *(grid_value_000+mul_tmp+6);\n"
"		cube[7] = *(grid_value_000+mul_tmp+7);\n"
"\n"
"		// Calculating affinity energy\n"
"		partial_energies[tidx] += q * (cube[0]*weights[0] + cube[1]*weights[1] + cube[2]*weights[2] + cube[3]*weights[3] + cube[4]*weights[4] + cube[5]*weights[5] + cube[6]*weights[6] + cube[7]*weights[7]);\n"
"		#if defined (DEBUG_ENERGY_KERNEL)\n"
"		partial_interE[tidx] += q *(cube[0]*weights[0] + cube[1]*weights[1] + cube[2]*weights[2] + cube[3]*weights[3] + cube[4]*weights[4] + cube[5]*weights[5] + cube[6]*weights[6] + cube[7]*weights[7]);\n"
"		#endif\n"
"\n"
"		qg = fabs(qg);\n"
"		// Vector in x-direction\n"
"		gx += qg * ( omdz * (omdy * (cube [idx_100] - cube [idx_000]) + dy * (cube [idx_110] - cube [idx_010])) +\n"
"		               dz * (omdy * (cube [idx_101] - cube [idx_001]) + dy * (cube [idx_111] - cube [idx_011])));\n"
"		// Vector in y-direction\n"
"		gy += qg * ( omdz * (omdx * (cube [idx_010] - cube [idx_000]) + dx * (cube [idx_110] - cube [idx_100])) +\n"
"		               dz * (omdx * (cube [idx_011] - cube [idx_001]) + dx * (cube [idx_111] - cube [idx_101])));\n"
"		// Vectors in z-direction\n"
"		gz += qg * ( omdy * (omdx * (cube [idx_001] - cube [idx_000]) + dx * (cube [idx_101] - cube [idx_100])) +\n"
"		               dy * (omdx * (cube [idx_011] - cube [idx_010]) + dx * (cube [idx_111] - cube [idx_110])));\n"
"		// -------------------------------------------------------------------\n"
"#ifdef FLOAT_GRADIENTS\n"
"		gradient_x[atom_id] += gx;\n"
"		gradient_y[atom_id] += gy;\n"
"		gradient_z[atom_id] += gz;\n"
"#else\n"
"		gradient_x[atom_id] += float2int_round(fmin(MAXTERM, fmax(-MAXTERM, TERMSCALE * gx)));\n"
"		gradient_y[atom_id] += float2int_round(fmin(MAXTERM, fmax(-MAXTERM, TERMSCALE * gy)));\n"
"		gradient_z[atom_id] += float2int_round(fmin(MAXTERM, fmax(-MAXTERM, TERMSCALE * gz)));\n"
"#endif\n"
"	} // End atom_id for-loop (INTERMOLECULAR ENERGY)\n"
"\n"
"	// Inter- and intra-molecular energy calculation\n"
"	// are independent from each other, so NO barrier is needed here.\n"
"	// As these two require different operations,\n"
"	// they can be executed only sequentially on the GPU.\n"
"	float delta_distance = 0.5f*dockpars_smooth;\n"
"	float smoothed_distance;\n"
"\n"
"	// ================================================\n"
"	// CALCULATING INTRAMOLECULAR GRADIENTS\n"
"	// ================================================\n"
"	for ( int contributor_counter = tidx;\n"
"	          contributor_counter < dockpars_num_of_intraE_contributors;\n"
"	          contributor_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		// Storing in a private variable \n"
"		// the gradient contribution of each contributing atomic pair\n"
"		float priv_gradient_per_intracontributor= 0.0f;\n"
"\n"
"		// Getting atom IDs\n"
"		uint atom1_id = kerconst_intracontrib->intraE_contributors_const[2*contributor_counter];\n"
"		uint atom2_id = kerconst_intracontrib->intraE_contributors_const[2*contributor_counter+1];\n"
"\n"
"		// Calculating vector components of vector going\n"
"		// from first atom's to second atom's coordinates\n"
"		float subx = calc_coords[atom1_id].x - calc_coords[atom2_id].x;\n"
"		float suby = calc_coords[atom1_id].y - calc_coords[atom2_id].y;\n"
"		float subz = calc_coords[atom1_id].z - calc_coords[atom2_id].z;\n"
"\n"
"		// Calculating atomic_distance\n"
"		float dist = native_sqrt(subx*subx + suby*suby + subz*subz);\n"
"		float atomic_distance = dist*dockpars_grid_spacing;\n"
"\n"
"		// Getting type IDs\n"
"		uint atom1_typeid = kerconst_interintra->atom_types_const[atom1_id];\n"
"		uint atom2_typeid = kerconst_interintra->atom_types_const[atom2_id];\n"
"\n"
"		uint atom1_type_vdw_hb = kerconst_intra->atom_types_reqm_const [atom1_typeid];\n"
"		uint atom2_type_vdw_hb = kerconst_intra->atom_types_reqm_const [atom2_typeid];\n"
"\n"
"		// ------------------------------------------------\n"
"		// Required only for flexrings\n"
"		// Checking if this is a CG-G0 atomic pair.\n"
"		// If so, then adding energy term (E = G * distance).\n"
"		// Initial specification required NON-SMOOTHED distance.\n"
"		// This interaction is evaluated at any distance,\n"
"		// so no cuttoffs considered here!\n"
"		// vbond is G when calculating flexrings, 0.0 otherwise\n"
"		float vbond = G * (float)(((atom1_type_vdw_hb == ATYPE_CG_IDX) && (atom2_type_vdw_hb == ATYPE_G0_IDX)) ||\n"
"					  ((atom1_type_vdw_hb == ATYPE_G0_IDX) && (atom2_type_vdw_hb == ATYPE_CG_IDX)));\n"
"		partial_energies[tidx] += vbond * atomic_distance;\n"
"		priv_gradient_per_intracontributor += vbond;\n"
"		// ------------------------------------------------\n"
"\n"
"		// Calculating energy contributions\n"
"		// Cuttoff1: internuclear-distance at 8A only for vdw and hbond\n"
"		if (atomic_distance < 8.0f)\n"
"		{\n"
"			uint idx = atom1_typeid * dockpars_num_of_atypes + atom2_typeid;\n"
"			ushort exps = kerconst_intra->VWpars_exp_const[idx];\n"
"			char m=(exps & 0xFF00)>>8;\n"
"			char n=(exps & 0xFF);\n"
"			// Getting optimum pair distance (opt_distance)\n"
"			float opt_distance = kerconst_intra->reqm_AB_const[idx];\n"
"\n"
"			// Getting smoothed distance\n"
"			// smoothed_distance = function(atomic_distance, opt_distance)\n"
"			float opt_dist_delta = opt_distance - atomic_distance;\n"
"			if(fabs(opt_dist_delta)>=delta_distance){\n"
"				smoothed_distance = atomic_distance + copysign(delta_distance,opt_dist_delta);\n"
"			} else smoothed_distance = opt_distance;\n"
"			// Calculating van der Waals / hydrogen bond term\n"
"			float rmn=native_powr(smoothed_distance,m-n);\n"
"			float rm=native_powr(smoothed_distance,-m);\n"
"			partial_energies[tidx] += (kerconst_intra->VWpars_AC_const[idx]-rmn*kerconst_intra->VWpars_BD_const[idx])*rm;\n"
"			priv_gradient_per_intracontributor += native_divide((n*kerconst_intra->VWpars_BD_const[idx]*rmn-m*kerconst_intra->VWpars_AC_const[idx])*rm,smoothed_distance);\n"
"			#if defined (DEBUG_ENERGY_KERNEL)\n"
"			partial_intraE[tidx] += (kerconst_intra->VWpars_AC_const[idx]-rmn*kerconst_intra->VWpars_BD_const[idx])*rm;\n"
"			#endif\n"
"		} // if cuttoff1 - internuclear-distance at 8A\n"
"\n"
"		// Calculating energy contributions\n"
"		// Cuttoff2: internuclear-distance at 20.48A only for el and sol.\n"
"		if (atomic_distance < 20.48f)\n"
"		{\n"
"			if(atomic_distance<dockpars_elec_min_distance) atomic_distance=dockpars_elec_min_distance;\n"
"			float q1 = kerconst_interintra->atom_charges_const[atom1_id];\n"
"			float q2 = kerconst_interintra->atom_charges_const[atom2_id];\n"
"//			float exp_el = native_exp(DIEL_B_TIMES_H*atomic_distance);\n"
"			float dist2 = atomic_distance*atomic_distance;\n"
"			// Calculating desolvation term\n"
"			// 1/25.92 = 0.038580246913580245\n"
"			float desolv_energy =  ((kerconst_intra->dspars_S_const[atom1_typeid] +\n"
"			                         dockpars_qasp*fabs(q1)) * kerconst_intra->dspars_V_const[atom2_typeid] +\n"
"			                        (kerconst_intra->dspars_S_const[atom2_typeid] +\n"
"			                         dockpars_qasp*fabs(q2)) * kerconst_intra->dspars_V_const[atom1_typeid]) *\n"
"			                       native_divide (\n"
"			                                      dockpars_coeff_desolv*(12.96f-0.1063f*dist2*(1.0f-0.001947f*dist2)),\n"
"			                                      (12.96f+dist2*(0.4137f+dist2*(0.00357f+0.000112f*dist2)))\n"
"			                                     );\n"
"//			                       dockpars_coeff_desolv*native_exp(-0.03858025f*atomic_distance*atomic_distance);\n"
"			// Calculating electrostatic term\n"
"/*			partial_energies[tidx] += native_divide (\n"
"			                                         dockpars_coeff_elec * q1 * q2,\n"
"			                                         atomic_distance * (DIEL_A + native_divide(DIEL_B,(1.0f + native_divide(DIEL_K,exp_el))))\n"
"			                                        ) +\n"
"			                          desolv_energy;*/\n"
"#ifndef DIEL_FIT_ABC\n"
"			float dist_shift=atomic_distance+1.26366f;\n"
"			dist2=dist_shift*dist_shift;\n"
"			float diel = native_divide(1.10859f,dist2)+0.010358f;\n"
"#else\n"
"			float dist_shift=atomic_distance+1.588f;\n"
"			dist2=dist_shift*dist_shift;\n"
"			float disth_shift=atomic_distance+0.794f;\n"
"			float disth4=disth_shift*disth_shift;\n"
"			disth4*=disth4;\n"
"			float diel = native_divide(1.404f,dist2)+native_divide(0.072f,disth4)+0.00831f;\n"
"#endif\n"
"			float es_energy = native_divide(dockpars_coeff_elec * q1 * q2,atomic_distance);\n"
"			partial_energies[tidx] += diel * es_energy + desolv_energy;\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL)\n"
"/*			partial_intraE[tidx] += native_divide (\n"
"			                                       dockpars_coeff_elec * q1 * q2,\n"
"			                                       atomic_distance * (DIEL_A + native_divide(DIEL_B,(1.0f + native_divide(DIEL_K,exp_el))))\n"
"			                                      ) +\n"
"			                        desolv_energy;*/\n"
"			partial_intraE[tidx] += diel * es_energy + desolv_energy;\n"
"			#endif\n"
"\n"
"			// http://www.wolframalpha.com/input/?i=1%2F(x*(A%2B(B%2F(1%2BK*exp(-h*B*x)))))\n"
"/*			float exp_el_DIEL_K = exp_el + DIEL_K;\n"
"			float upper = DIEL_A * exp_el_DIEL_K*exp_el_DIEL_K +\n"
"			              DIEL_B * exp_el * (DIEL_B_TIMES_H_TIMES_K*atomic_distance + exp_el_DIEL_K);\n"
"			float lower = atomic_distance * (DIEL_A * exp_el_DIEL_K + DIEL_B * exp_el);\n"
"			lower *= lower;*/\n"
"\n"
"//			priv_gradient_per_intracontributor +=  -dockpars_coeff_elec * q1 * q2 * native_divide (upper, lower) -\n"
"//			                                       0.0771605f * atomic_distance * desolv_energy;\n"
"			priv_gradient_per_intracontributor +=  native_divide(-es_energy,atomic_distance) * diel\n"
"#ifndef DIEL_FIT_ABC\n"
"			                                       -native_divide(es_energy * 2.21718f,dist2*dist_shift)\n"
"#else\n"
"			                                       -es_energy * (native_divide(2.808f,dist2*dist_shift)+native_divide(0.288f,disth4*disth_shift))\n"
"#endif\n"
"			                                       -0.0771605f * atomic_distance * desolv_energy; // 1/3.6^2 = 1/12.96 = 0.0771605\n"
"		} // if cuttoff2 - internuclear-distance at 20.48A\n"
"\n"
"		// Decomposing \"priv_gradient_per_intracontributor\"\n"
"		// into the contribution of each atom of the pair.\n"
"		// Distances in Angstroms of vector that goes from\n"
"		// \"atom1_id\"-to-\"atom2_id\", therefore - subx, - suby, and - subz are used\n"
"		float grad_div_dist = native_divide(-priv_gradient_per_intracontributor,dist);\n"
"#ifdef FLOAT_GRADIENTS\n"
"		float priv_intra_gradient_x = subx * grad_div_dist;\n"
"		float priv_intra_gradient_y = suby * grad_div_dist;\n"
"		float priv_intra_gradient_z = subz * grad_div_dist;\n"
"#else\n"
"		int priv_intra_gradient_x = float2int_round(fmin(MAXTERM, fmax(-MAXTERM, TERMSCALE * subx * grad_div_dist)));\n"
"		int priv_intra_gradient_y = float2int_round(fmin(MAXTERM, fmax(-MAXTERM, TERMSCALE * suby * grad_div_dist)));\n"
"		int priv_intra_gradient_z = float2int_round(fmin(MAXTERM, fmax(-MAXTERM, TERMSCALE * subz * grad_div_dist)));\n"
"#endif\n"
"		// Calculating gradients in xyz components.\n"
"		// Gradients for both atoms in a single contributor pair\n"
"		// have the same magnitude, but opposite directions\n"
"#ifdef FLOAT_GRADIENTS // the floating point atomic adds are time consuming\n"
"		atomicSub_g_f(&gradient_x[atom1_id], priv_intra_gradient_x);\n"
"		atomicSub_g_f(&gradient_y[atom1_id], priv_intra_gradient_y);\n"
"		atomicSub_g_f(&gradient_z[atom1_id], priv_intra_gradient_z);\n"
"\n"
"		atomicAdd_g_f(&gradient_x[atom2_id], priv_intra_gradient_x);\n"
"		atomicAdd_g_f(&gradient_y[atom2_id], priv_intra_gradient_y);\n"
"		atomicAdd_g_f(&gradient_z[atom2_id], priv_intra_gradient_z);\n"
"#else\n"
"		atomic_sub(&gradient_x[atom1_id], priv_intra_gradient_x);\n"
"		atomic_sub(&gradient_y[atom1_id], priv_intra_gradient_y);\n"
"		atomic_sub(&gradient_z[atom1_id], priv_intra_gradient_z);\n"
"\n"
"		atomic_add(&gradient_x[atom2_id], priv_intra_gradient_x);\n"
"		atomic_add(&gradient_y[atom2_id], priv_intra_gradient_y);\n"
"		atomic_add(&gradient_z[atom2_id], priv_intra_gradient_z);\n"
"#endif\n"
"	} // End contributor_counter for-loop (INTRAMOLECULAR ENERGY)\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// -------------------------------------------------------\n"
"	// Obtaining energy and translation-related gradients\n"
"	// -------------------------------------------------------\n"
"	accumulator_x[tidx] = 0.0f;\n"
"	accumulator_y[tidx] = 0.0f;\n"
"	accumulator_z[tidx] = 0.0f;\n"
"	for ( int atom_cnt = tidx;\n"
"	          atom_cnt < dockpars_num_of_atoms;\n"
"	          atom_cnt+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"#ifdef FLOAT_GRADIENTS\n"
"		accumulator_x[tidx] += gradient_x[atom_cnt];\n"
"		accumulator_y[tidx] += gradient_y[atom_cnt];\n"
"		accumulator_z[tidx] += gradient_z[atom_cnt];\n"
"#else\n"
"		accumulator_x[tidx] += ONEOVERTERMSCALE * gradient_x[atom_cnt];\n"
"		accumulator_y[tidx] += ONEOVERTERMSCALE * gradient_y[atom_cnt];\n"
"		accumulator_z[tidx] += ONEOVERTERMSCALE * gradient_z[atom_cnt];\n"
"#endif\n"
"	}\n"
"	// reduction over partial energies and prepared \"gradient_intra_*\" values\n"
"	for ( int off=NUM_OF_THREADS_PER_BLOCK>>1; off>0; off >>= 1)\n"
"	{\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		if (tidx < off)\n"
"		{\n"
"			partial_energies[tidx] += partial_energies[tidx+off];\n"
"#if defined (DEBUG_ENERGY_KERNEL)\n"
"			partial_intraE[tidx] += partial_intraE[tidx+off];\n"
"#endif\n"
"			accumulator_x[tidx] += accumulator_x[tidx+off];\n"
"			accumulator_y[tidx] += accumulator_y[tidx+off];\n"
"			accumulator_z[tidx] += accumulator_z[tidx+off];\n"
"		}\n"
"	}\n"
"#ifndef FLOAT_GRADIENTS\n"
"	__local int* i_gradient_genotype = (__local int*)gradient_genotype;\n"
"#endif\n"
"	if (tidx == 0) {\n"
"		*energy = partial_energies[0];\n"
"		// Scaling gradient for translational genes as\n"
"		// their corresponding gradients were calculated in the space\n"
"		// where these genes are in Angstrom,\n"
"		// but AutoDock-GPU translational genes are within in grids\n"
"		if(dockpars_true_ligand_atoms){\n"
"#ifdef FLOAT_GRADIENTS\n"
"			gradient_genotype[0] = accumulator_x[0] * dockpars_grid_spacing;\n"
"			gradient_genotype[1] = accumulator_y[0] * dockpars_grid_spacing;\n"
"			gradient_genotype[2] = accumulator_z[0] * dockpars_grid_spacing;\n"
"			#if defined (PRINT_GRAD_TRANSLATION_GENES)\n"
"			printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"			printf(\"gradient_x:%f\\n\", gradient_genotype [0]);\n"
"			printf(\"gradient_y:%f\\n\", gradient_genotype [1]);\n"
"			printf(\"gradient_z:%f\\n\", gradient_genotype [2]);\n"
"			#endif\n"
"#else\n"
"			i_gradient_genotype[0] = float2int_round(fmin(MAXTERM, fmax(-MAXTERM, TERMSCALE * accumulator_x[0] * dockpars_grid_spacing)));\n"
"			i_gradient_genotype[1] = float2int_round(fmin(MAXTERM, fmax(-MAXTERM, TERMSCALE * accumulator_y[0] * dockpars_grid_spacing)));\n"
"			i_gradient_genotype[2] = float2int_round(fmin(MAXTERM, fmax(-MAXTERM, TERMSCALE * accumulator_z[0] * dockpars_grid_spacing)));\n"
"			#if defined (PRINT_GRAD_TRANSLATION_GENES)\n"
"			printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"			printf(\"i_gradient_x:%f\\n\", i_gradient_genotype [0]);\n"
"			printf(\"i_gradient_y:%f\\n\", i_gradient_genotype [1]);\n"
"			printf(\"i_gradient_z:%f\\n\", i_gradient_genotype [2]);\n"
"			#endif\n"
"#endif\n"
"		}\n"
"	}\n"
"\n"
"	// ------------------------------------------\n"
"	// Obtaining rotation-related gradients\n"
"	// ------------------------------------------ \n"
"				\n"
"	// Transform gradients_inter_{x|y|z} \n"
"	// into local_gradients[i] (with four quaternion genes)\n"
"	// Derived from autodockdev/motions.py/forces_to_delta_genes()\n"
"\n"
"	// Transform local_gradients[i] (with four quaternion genes)\n"
"	// into local_gradients[i] (with three Shoemake genes)\n"
"	// Derived from autodockdev/motions.py/_get_cube3_gradient()\n"
"	// ------------------------------------------\n"
"\n"
"	if(dockpars_true_ligand_atoms){\n"
"		accumulator_x[tidx] = 0.0f;\n"
"		accumulator_y[tidx] = 0.0f;\n"
"		accumulator_z[tidx] = 0.0f;\n"
"		for ( int atom_cnt = tidx;\n"
"		          atom_cnt < dockpars_true_ligand_atoms;\n"
"		          atom_cnt+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			float4 r = (calc_coords[atom_cnt] - genrot_movingvec) * dockpars_grid_spacing;\n"
"			// Re-using \"gradient_inter_*\" for total gradient (inter+intra)\n"
"			float4 force;\n"
"#ifdef FLOAT_GRADIENTS\n"
"			force.x = gradient_x[atom_cnt];\n"
"			force.y = gradient_y[atom_cnt];\n"
"			force.z = gradient_z[atom_cnt];\n"
"#else\n"
"			force.x = ONEOVERTERMSCALE * gradient_x[atom_cnt];\n"
"			force.y = ONEOVERTERMSCALE * gradient_y[atom_cnt];\n"
"			force.z = ONEOVERTERMSCALE * gradient_z[atom_cnt];\n"
"#endif\n"
"			force.w = 0.0f;\n"
"			float4 torque_rot = cross(r, force);\n"
"			accumulator_x[tidx] += torque_rot.x;\n"
"			accumulator_y[tidx] += torque_rot.y;\n"
"			accumulator_z[tidx] += torque_rot.z;\n"
"		}\n"
"		// do a reduction over the total gradient containing prepared \"gradient_intra_*\" values\n"
"		for ( int off=NUM_OF_THREADS_PER_BLOCK>>1; off>0; off >>= 1)\n"
"		{\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"			if (tidx < off)\n"
"			{\n"
"				accumulator_x[tidx] += accumulator_x[tidx+off];\n"
"				accumulator_y[tidx] += accumulator_y[tidx+off];\n"
"				accumulator_z[tidx] += accumulator_z[tidx+off];\n"
"			}\n"
"		}\n"
"		if (tidx == 0) {\n"
"			float4 torque_rot;\n"
"			torque_rot.x = accumulator_x[0];\n"
"			torque_rot.y = accumulator_y[0];\n"
"			torque_rot.z = accumulator_z[0];\n"
"\n"
"			#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"			printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"			printf(\"%-20s %-10.6f %-10.6f %-10.6f\\n\", \"final torque: \", torque_rot.x, torque_rot.y, torque_rot.z);\n"
"			#endif\n"
"\n"
"			// Derived from rotation.py/axisangle_to_q()\n"
"			// genes[3:7] = rotation.axisangle_to_q(torque, rad)\n"
"			float torque_length = native_sqrt(torque_rot.x*torque_rot.x+torque_rot.y*torque_rot.y+torque_rot.z*torque_rot.z);\n"
"			float orientation_scaling = orientation_scaling = (torque_length<INFINITESIMAL_RADIAN) ? 1.0f : torque_length * INV_INFINITESIMAL_RADIAN;\n"
"\n"
"			torque_rot *= (torque_length<INFINITESIMAL_RADIAN) ? 0.5f - native_divide(torque_length*torque_length,48.0f) : native_divide(SIN_HALF_INFINITESIMAL_RADIAN,torque_length);\n"
"\n"
"			#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"			printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"			printf(\"%-20s %-10.6f\\n\", \"torque length: \", torque_length);\n"
"			#endif\n"
"\n"
"			// Finding the quaternion that performs\n"
"			// the infinitesimal rotation around torque axis\n"
"			float4 quat_torque;\n"
"			quat_torque.x = torque_rot.x;\n"
"			quat_torque.y = torque_rot.y;\n"
"			quat_torque.z = torque_rot.z;\n"
"			quat_torque.w = (torque_length<INFINITESIMAL_RADIAN) ? 1.0f-torque_length*torque_length*0.125f : COS_HALF_INFINITESIMAL_RADIAN;\n"
"\n"
"			#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"			printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"			printf(\"%-20s %-10.6f\\n\", \"INFINITESIMAL_RADIAN: \", INFINITESIMAL_RADIAN);\n"
"			printf(\"%-20s %-10.6f %-10.6f %-10.6f %-10.6f\\n\", \"quat_torque (w,x,y,z): \", quat_torque.w, quat_torque.x, quat_torque.y, quat_torque.z);\n"
"			#endif\n"
"\n"
"			// Converting quaternion gradients into orientation gradients \n"
"			// Derived from autodockdev/motion.py/_get_cube3_gradient\n"
"			#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"			printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"			printf(\"%-30s %-10.6f %-10.6f %-10.6f %-10.6f\\n\", \"current_q (w,x,y,z): \", genrot_unitvec.w, genrot_unitvec.x, genrot_unitvec.y, genrot_unitvec.z);\n"
"			#endif\n"
"\n"
"			// This is where we want to be in quaternion space\n"
"			// target_q = rotation.q_mult(q, current_q)\n"
"			float4 target_q = quaternion_multiply(quat_torque, genrot_unitvec);\n"
"\n"
"			#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"			printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"			printf(\"%-30s %-10.6f %-10.6f %-10.6f %-10.6f\\n\", \"target_q (w,x,y,z): \", target_q.w, target_q.x, target_q.y, target_q.z);\n"
"			#endif\n"
"\n"
"			// This is where we are in the orientation axis-angle space\n"
"			// Equivalent to \"current_oclacube\" in autodockdev/motions.py\n"
"			float current_phi      = fmod_pi2(PI_TIMES_2 + phi);\n"
"			float current_theta    = fmod_pi2(PI_TIMES_2 + theta);\n"
"			float current_rotangle = fmod_pi2(PI_TIMES_2 + genrotangle);\n"
"\n"
"			// This is where we want to be in the orientation axis-angle space\n"
"			float target_phi, target_theta, target_rotangle;\n"
"\n"
"			// target_oclacube = quaternion_to_oclacube(target_q, theta_larger_than_pi)\n"
"			// Derived from autodockdev/motions.py/quaternion_to_oclacube()\n"
"			// In our terms means quaternion_to_oclacube(target_q{w|x|y|z}, theta_larger_than_pi)\n"
"			target_rotangle = 2.0f * fast_acos(target_q.w); // = 2.0f * ang;\n"
"			float inv_sin_ang = native_rsqrt(1.0f-target_q.w*target_q.w); // = 1.0/native_sin(ang);\n"
"\n"
"			target_theta = PI_TIMES_2 + is_theta_gt_pi * fast_acos( target_q.z * inv_sin_ang );\n"
"			target_phi   = fmod_pi2((atan2( is_theta_gt_pi*target_q.y, is_theta_gt_pi*target_q.x) + PI_TIMES_2));\n"
"\n"
"			#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"			printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"			printf(\"%-30s %-10.6f %-10.6f %-10.6f\\n\", \"target_axisangle (1,2,3): \", target_phi, target_theta, target_rotangle);\n"
"			#endif\n"
"\n"
"			// The infinitesimal rotation will produce an infinitesimal displacement\n"
"			// in shoemake space. This is to guarantee that the direction of\n"
"			// the displacement in shoemake space is not distorted.\n"
"			// The correct amount of displacement in shoemake space is obtained\n"
"			// by multiplying the infinitesimal displacement by shoemake_scaling:\n"
"\n"
"			#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"			printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"			printf(\"%-30s %-10.6f\\n\", \"orientation_scaling: \", orientation_scaling);\n"
"			#endif\n"
"\n"
"			// Derivates in cube3\n"
"			float grad_phi      = orientation_scaling * (fmod_pi2(target_phi      - current_phi      + PI_FLOAT) - PI_FLOAT);\n"
"			float grad_theta    = orientation_scaling * (fmod_pi2(target_theta    - current_theta    + PI_FLOAT) - PI_FLOAT);\n"
"			float grad_rotangle = orientation_scaling * (fmod_pi2(target_rotangle - current_rotangle + PI_FLOAT) - PI_FLOAT);\n"
"\n"
"			float rot_angle_corr = 4.0f * sin_half_rotangle * sin_half_rotangle; // 4*sin(rotangle/2)^2\n"
"			\n"
"			// Setting gradient rotation-related genotypes in cube\n"
"			// Multiplicating by DEG_TO_RAD is to make it uniform to DEG (see torsion gradients)\n"
"#ifdef FLOAT_GRADIENTS\n"
"			gradient_genotype[3] = grad_phi * sin_theta * sin_theta * rot_angle_corr * DEG_TO_RAD;\n"
"			gradient_genotype[4] = grad_theta * rot_angle_corr * DEG_TO_RAD;\n"
"			gradient_genotype[5] = grad_rotangle * DEG_TO_RAD;\n"
"#else\n"
"			i_gradient_genotype[3] = float2int_round(fmin(MAXTERM, fmax(-MAXTERM, TERMSCALE * grad_phi * sin_theta * sin_theta * rot_angle_corr * DEG_TO_RAD)));\n"
"			i_gradient_genotype[4] = float2int_round(fmin(MAXTERM, fmax(-MAXTERM, TERMSCALE * grad_theta * rot_angle_corr * DEG_TO_RAD)));\n"
"			i_gradient_genotype[5] = float2int_round(fmin(MAXTERM, fmax(-MAXTERM, TERMSCALE * grad_rotangle * DEG_TO_RAD)));\n"
"#endif\n"
"			#if defined (PRINT_GRAD_ROTATION_GENES)\n"
"			printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"			printf(\"%-30s \\n\", \"grad_axisangle (1,2,3) - after empirical scaling: \");\n"
"			printf(\"%-13s %-13s %-13s \\n\", \"grad_phi\", \"grad_theta\", \"grad_rotangle\");\n"
"			printf(\"%-13.6f %-13.6f %-13.6f\\n\", gradient_genotype[3], gradient_genotype[4], gradient_genotype[5]);\n"
"			#endif\n"
"		}\n"
"	}\n"
"\n"
"	// ------------------------------------------\n"
"	// Obtaining torsion-related gradients\n"
"	// ------------------------------------------\n"
"	int num_torsion_genes = dockpars_num_of_genes-6;\n"
"	for ( int idx = tidx;\n"
"	          idx < num_torsion_genes * dockpars_num_of_atoms;\n"
"	          idx += NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		int rotable_atom_cnt = idx / num_torsion_genes;\n"
"		int rotbond_id = idx - rotable_atom_cnt * num_torsion_genes; // this is a bit cheaper than % (modulo)\n"
"\n"
"		if (rotable_atom_cnt >= num_rotating_atoms_per_rotbond_const[rotbond_id])\n"
"			continue; // Nothing to do\n"
"\n"
"		// Querying ids of atoms belonging to the rotatable bond in question\n"
"		int atom1_id = rotbonds_const[2*rotbond_id];\n"
"		int atom2_id = rotbonds_const[2*rotbond_id+1];\n"
"\n"
"		float4 atomRef_coords;\n"
"		atomRef_coords = calc_coords[atom1_id];\n"
"		float4 rotation_unitvec = fast_normalize(calc_coords[atom2_id] - atomRef_coords);\n"
"\n"
"		// Torque of torsions\n"
"		uint lig_atom_id = rotbonds_atoms_const[MAX_NUM_OF_ATOMS*rotbond_id + rotable_atom_cnt];\n"
"		float4 torque_tor, r, atom_force;\n"
"\n"
"		// Calculating torque on point \"A\"\n"
"		// They are converted back to Angstroms here\n"
"		r = (calc_coords[lig_atom_id] - atomRef_coords);\n"
"\n"
"		// Re-using \"gradient_inter_*\" for total gradient (inter+intra)\n"
"#ifdef FLOAT_GRADIENTS\n"
"		atom_force.x = gradient_x[lig_atom_id];\n"
"		atom_force.y = gradient_y[lig_atom_id];\n"
"		atom_force.z = gradient_z[lig_atom_id];\n"
"#else\n"
"		atom_force.x = ONEOVERTERMSCALE * gradient_x[lig_atom_id];\n"
"		atom_force.y = ONEOVERTERMSCALE * gradient_y[lig_atom_id];\n"
"		atom_force.z = ONEOVERTERMSCALE * gradient_z[lig_atom_id];\n"
"#endif\n"
"		atom_force.w = 0.0f;\n"
"\n"
"		torque_tor = cross(r, atom_force);\n"
"		float torque_on_axis = dot(rotation_unitvec, torque_tor) * dockpars_grid_spacing; // it is cheaper to do a scalar multiplication than a vector one\n"
"\n"
"		// Assignment of gene-based gradient\n"
"		// - this works because a * (a_1 + a_2 + ... + a_n) = a*a_1 + a*a_2 + ... + a*a_n\n"
"#ifdef FLOAT_GRADIENTS\n"
"		atomicAdd_g_f(&gradient_genotype[rotbond_id+6], torque_on_axis * DEG_TO_RAD); /*(M_PI / 180.0f)*/;\n"
"#else\n"
"		atomic_add(&i_gradient_genotype[rotbond_id+6], float2int_round(fmin(MAXTERM, fmax(-MAXTERM, TERMSCALE * torque_on_axis * DEG_TO_RAD)))); /*(M_PI / 180.0f)*/;\n"
"#endif\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifndef FLOAT_GRADIENTS\n"
"	for ( int gene_cnt = tidx;\n"
"	          gene_cnt < dockpars_num_of_genes;\n"
"	          gene_cnt+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		gradient_genotype[gene_cnt] = ONEOVERTERMSCALE * (float)i_gradient_genotype[gene_cnt];\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"\n"
"#if defined (CONVERT_INTO_ANGSTROM_RADIAN)\n"
"	for ( int gene_cnt = tidx+3; // Only for gene_cnt > 2 means start gene_cnt at 3\n"
"	          gene_cnt < dockpars_num_of_genes;\n"
"	          gene_cnt+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		gradient_genotype[gene_cnt] *= dockpars_grid_spacing * dockpars_grid_spacing * SCFACTOR_ANGSTROM_RADIAN;\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"}\n"
"/*\n"
"\n"
"AutoDock-GPU, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"For some of the code, Copyright (C) 2019 Computational Structural Biology Center, the Scripps Research Institute.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This library is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU Lesser General Public\n"
"License as published by the Free Software Foundation; either\n"
"version 2.1 of the License, or (at your option) any later version.\n"
"\n"
"This library is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"Lesser General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU Lesser General Public\n"
"License along with this library; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n"
"\n"
"*/\n"
"\n"
"\n"
"//#define DEBUG_ENERGY_KERNEL1\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gpu_calc_initpop(\n"
"                       int    dockpars_num_of_atoms,\n"
"                       int    dockpars_true_ligand_atoms,\n"
"                       int    dockpars_num_of_atypes,\n"
"                       int    dockpars_num_of_map_atypes,\n"
"                       int    dockpars_num_of_intraE_contributors,\n"
"                       int    dockpars_gridsize_x,\n"
"                       int    dockpars_gridsize_y,\n"
"                       int    dockpars_gridsize_z,\n"
"                                                                   // g1 = gridsize_x\n"
"                       uint   dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"                       uint   dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"                       float  dockpars_grid_spacing,\n"
"        __global const float* restrict dockpars_fgrids, // This is too large to be allocated in __constant\n"
"                       int    dockpars_rotbondlist_length,\n"
"                       float  dockpars_coeff_elec,\n"
"                       float  dockpars_elec_min_distance,\n"
"                       float  dockpars_coeff_desolv,\n"
"        __global const float* restrict dockpars_conformations_current,\n"
"        __global       float* restrict dockpars_energies_current,\n"
"        __global       int*   restrict dockpars_evals_of_new_entities,\n"
"                       int    dockpars_pop_size,\n"
"                       float  dockpars_qasp,\n"
"                       float  dockpars_smooth,\n"
"\n"
"      __constant       kernelconstant_interintra*   kerconst_interintra,\n"
"        __global const kernelconstant_intracontrib* kerconst_intracontrib,\n"
"      __constant       kernelconstant_intra*        kerconst_intra,\n"
"      __constant       kernelconstant_rotlist*      kerconst_rotlist,\n"
"      __constant       kernelconstant_conform*      kerconst_conform\n"
"                )\n"
"{\n"
"	// Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"	__local float  genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float  energy;\n"
"	__local int    run_id;\n"
"\n"
"	__local float4 calc_coords[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"	#if defined (DEBUG_ENERGY_KERNEL)\n"
"	__local float partial_interE[NUM_OF_THREADS_PER_BLOCK];\n"
"	__local float partial_intraE[NUM_OF_THREADS_PER_BLOCK];\n"
"	#endif\n"
"\n"
"	// Copying genotype from global memory\n"
"	event_t ev = async_work_group_copy(genotype,\n"
"	                                   dockpars_conformations_current + GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0),\n"
"	                                   ACTUAL_GENOTYPE_LENGTH, 0);\n"
"\n"
"	int tidx = get_local_id(0);\n"
"	// Determining run-ID\n"
"	if (tidx == 0) {\n"
"		run_id = get_group_id(0) / dockpars_pop_size;\n"
"	}\n"
"\n"
"	// Asynchronous copy should be finished by here\n"
"	wait_group_events(1, &ev);\n"
"\n"
"	// Evaluating initial genotypes\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// =============================================================\n"
"	gpu_calc_energy( dockpars_rotbondlist_length,\n"
"	                 dockpars_num_of_atoms,\n"
"	                 dockpars_true_ligand_atoms,\n"
"	                 dockpars_gridsize_x,\n"
"	                 dockpars_gridsize_y,\n"
"	                 dockpars_gridsize_z,\n"
"	                                                      // g1 = gridsize_x\n"
"	                 dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"	                 dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"	                 dockpars_fgrids,\n"
"	                 dockpars_num_of_atypes,\n"
"	                 dockpars_num_of_map_atypes,\n"
"	                 dockpars_num_of_intraE_contributors,\n"
"	                 dockpars_grid_spacing,\n"
"	                 dockpars_coeff_elec,\n"
"	                 dockpars_elec_min_distance,\n"
"	                 dockpars_qasp,\n"
"	                 dockpars_coeff_desolv,\n"
"	                 dockpars_smooth,\n"
"\n"
"	                 genotype,\n"
"	                 &energy,\n"
"	                 &run_id,\n"
"	                 // Some OpenCL compilers don't allow declaring\n"
"	                 // local variables within non-kernel functions.\n"
"	                 // These local variables must be declared in a kernel,\n"
"	                 // and then passed to non-kernel functions.\n"
"	                 calc_coords,\n"
"	                 partial_energies,\n"
"	                 #if defined (DEBUG_ENERGY_KERNEL)\n"
"	                 partial_interE,\n"
"	                 partial_intraE,\n"
"	                 #endif\n"
"#if 0\n"
"	                false,\n"
"#endif\n"
"	                kerconst_interintra,\n"
"	                kerconst_intracontrib,\n"
"	                kerconst_intra,\n"
"	                kerconst_rotlist,\n"
"	                kerconst_conform\n"
"	              );\n"
"	// =============================================================\n"
"\n"
"	if (tidx == 0) {\n"
"		dockpars_energies_current[get_group_id(0)] = energy;\n"
"		dockpars_evals_of_new_entities[get_group_id(0)] = 1;\n"
"		#if defined (DEBUG_ENERGY_KERNEL1)\n"
"		printf(\"%-18s [%-5s]---{%-5s}   [%-10.8f]---{%-10.8f}\\n\", \"-ENERGY-KERNEL1-\", \"GRIDS\", \"INTRA\", partial_interE[0], partial_intraE[0]);\n"
"		#endif\n"
"	}\n"
"}\n"
"/*\n"
"\n"
"AutoDock-GPU, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"For some of the code, Copyright (C) 2019 Computational Structural Biology Center, the Scripps Research Institute.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This library is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU Lesser General Public\n"
"License as published by the Free Software Foundation; either\n"
"version 2.1 of the License, or (at your option) any later version.\n"
"\n"
"This library is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"Lesser General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU Lesser General Public\n"
"License along with this library; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n"
"\n"
"*/\n"
"\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gpu_sum_evals(\n"
"              int pop_size,\n"
"     __global int* restrict dockpars_evals_of_new_entities,\n"
"     __global int* restrict evals_of_runs\n"
"             )\n"
"// The GPU global function sums the evaluation counter states\n"
"// which are stored in evals_of_new_entities array foreach entity,\n"
"// calculates the sums for each run and stores it in evals_of_runs array.\n"
"// The number of blocks which should be started equals to num_of_runs,\n"
"// since each block performs the summation for one run.\n"
"{\n"
"	int entity_counter;\n"
"	__local int partsum_evals[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	int tidx = get_local_id(0);\n"
"	partsum_evals[tidx] = 0;\n"
"\n"
"	// calculate partial sums\n"
"	for (entity_counter = tidx;\n"
"	     entity_counter < pop_size;\n"
"	     entity_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		partsum_evals[tidx] += dockpars_evals_of_new_entities[get_group_id(0)*pop_size + entity_counter];\n"
"	}\n"
"	// reduction to calculate energy\n"
"	for (int off=NUM_OF_THREADS_PER_BLOCK>>1; off>0; off >>= 1)\n"
"	{\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		if (tidx < off)\n"
"		{\n"
"			partsum_evals[tidx] += partsum_evals[tidx+off];\n"
"		}\n"
"	}\n"
"	if (tidx == 0)\n"
"		evals_of_runs[get_group_id(0)] += partsum_evals[0];\n"
"}\n"
"\n"
"/*\n"
"\n"
"AutoDock-GPU, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"For some of the code, Copyright (C) 2019 Computational Structural Biology Center, the Scripps Research Institute.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This library is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU Lesser General Public\n"
"License as published by the Free Software Foundation; either\n"
"version 2.1 of the License, or (at your option) any later version.\n"
"\n"
"This library is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"Lesser General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU Lesser General Public\n"
"License along with this library; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n"
"\n"
"*/\n"
"\n"
"\n"
"// if defined, new (experimental) GA genotype mutation, similar to experimental SW move,\n"
"// dependent on nr of atoms on torsions of ligand is used, not ready yet ...\n"
"// #define GA_MUTATION_TEST\n"
"\n"
"//#define DEBUG_ENERGY_KERNEL4\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gpu_gen_and_eval_newpops(\n"
"                               int    dockpars_num_of_atoms,\n"
"                               int    dockpars_true_ligand_atoms,\n"
"                               int    dockpars_num_of_atypes,\n"
"                               int    dockpars_num_of_map_atypes,\n"
"                               int    dockpars_num_of_intraE_contributors,\n"
"                               int    dockpars_gridsize_x,\n"
"                               int    dockpars_gridsize_y,\n"
"                               int    dockpars_gridsize_z,\n"
"                                                                           // g1 = gridsize_x\n"
"                               uint   dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"                               uint   dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"                               float  dockpars_grid_spacing,\n"
"                __global const float* restrict dockpars_fgrids, // This is too large to be allocated in __constant\n"
"                               int    dockpars_rotbondlist_length,\n"
"                               float  dockpars_coeff_elec,\n"
"                               float  dockpars_elec_min_distance,\n"
"                               float  dockpars_coeff_desolv,\n"
"                __global const float* restrict  dockpars_conformations_current,\n"
"                __global       float* restrict  dockpars_energies_current,\n"
"                __global       float* restrict  dockpars_conformations_next,\n"
"                __global       float* restrict  dockpars_energies_next,\n"
"                __global       int*   restrict  dockpars_evals_of_new_entities,\n"
"                __global       uint*  restrict dockpars_prng_states,\n"
"                               int    dockpars_pop_size,\n"
"                               int    dockpars_num_of_genes,\n"
"                               float  dockpars_tournament_rate,\n"
"                               float  dockpars_crossover_rate,\n"
"                               float  dockpars_mutation_rate,\n"
"                               float  dockpars_abs_max_dmov,\n"
"                               float  dockpars_abs_max_dang,\n"
"                               float  dockpars_qasp,\n"
"                               float  dockpars_smooth,\n"
"\n"
"              __constant       kernelconstant_interintra*   kerconst_interintra,\n"
"                __global const kernelconstant_intracontrib* kerconst_intracontrib,\n"
"              __constant       kernelconstant_intra*        kerconst_intra,\n"
"              __constant       kernelconstant_rotlist*      kerconst_rotlist,\n"
"              __constant       kernelconstant_conform*      kerconst_conform\n"
"                        )\n"
"// The GPU global function\n"
"{\n"
"	// Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"	__local float offspring_genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local int parent_candidates[4];\n"
"	__local float candidate_energies[4];\n"
"	__local int parents[2];\n"
"	__local int run_id;\n"
"	__local int covr_point[2];\n"
"	__local float randnums[10];\n"
"	int temp_covr_point;\n"
"	int gene_counter;\n"
"	__local float energy; // could be shared since only thread 0 will use it\n"
"\n"
"	__local float best_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"	__local int best_IDs[NUM_OF_THREADS_PER_BLOCK];\n"
"        __local int best_ID[1]; //__local int best_ID;\n"
"\n"
"	__local float4 calc_coords[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"	#if defined (DEBUG_ENERGY_KERNEL)\n"
"	__local float partial_interE [NUM_OF_THREADS_PER_BLOCK];\n"
"	__local float partial_intraE [NUM_OF_THREADS_PER_BLOCK];\n"
"	#endif\n"
"\n"
"	int tidx = get_local_id(0);\n"
"	// In this case this compute-unit is responsible for elitist selection\n"
"	if ((get_group_id(0) % dockpars_pop_size) == 0) {\n"
"		gpu_perform_elitist_selection(dockpars_pop_size,\n"
"		                              dockpars_energies_current,\n"
"		                              dockpars_energies_next,\n"
"		                              dockpars_evals_of_new_entities,\n"
"		                              dockpars_num_of_genes,\n"
"		                              dockpars_conformations_next,\n"
"		                              dockpars_conformations_current,\n"
"		                              best_energies,\n"
"		                              best_IDs,\n"
"		                              best_ID);\n"
"	}\n"
"	else\n"
"	{\n"
"		// Generating the following random numbers:\n"
"		// [0..3] for parent candidates,\n"
"		// [4..5] for binary tournaments, [6] for deciding crossover,\n"
"		// [7..8] for crossover points, [9] for local search\n"
"		for (gene_counter = tidx;\n"
"		     gene_counter < 10;\n"
"		     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			randnums[gene_counter] = gpu_randf(dockpars_prng_states);\n"
"		}\n"
"\n"
"		// Determining run ID\n"
"		if (tidx == 0) {\n"
"			run_id = get_group_id(0) / dockpars_pop_size;\n"
"		}\n"
"\n"
"		// Performing binary tournament selection\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		for (gene_counter = tidx;\n"
"		     gene_counter < 4;\n"
"		     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\\\n"
"		{ //it is not ensured that the four candidates will be different...\n"
"			parent_candidates[gene_counter]  = (int) (dockpars_pop_size*randnums[gene_counter]); //using randnums[0..3]\n"
"			candidate_energies[gene_counter] = dockpars_energies_current[run_id*dockpars_pop_size+parent_candidates[gene_counter]];\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		for (gene_counter = tidx;\n"
"		     gene_counter < 2;\n"
"		     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			// Notice: dockpars_tournament_rate was scaled down to [0,1] in host\n"
"			// to reduce number of operations in device\n"
"			if (candidate_energies[2*gene_counter] < candidate_energies[2*gene_counter+1])\n"
"				if (/*100.0f**/randnums[4+gene_counter] < dockpars_tournament_rate) { //using randnum[4..5]\n"
"					parents[gene_counter] = parent_candidates[2*gene_counter];\n"
"				}\n"
"				else {\n"
"					parents[gene_counter] = parent_candidates[2*gene_counter+1];\n"
"				}\n"
"			else\n"
"				if (/*100.0f**/randnums[4+gene_counter] < dockpars_tournament_rate) {\n"
"					parents[gene_counter] = parent_candidates[2*gene_counter+1];\n"
"				}\n"
"				else {\n"
"					parents[gene_counter] = parent_candidates[2*gene_counter];\n"
"				}\n"
"		}\n"
"\n"
"		// Performing crossover\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// Notice: dockpars_crossover_rate was scaled down to [0,1] in host\n"
"		// to reduce number of operations in device\n"
"		if (/*100.0f**/randnums[6] < dockpars_crossover_rate) // Using randnums[6]\n"
"		{\n"
"			for (gene_counter = tidx;\n"
"			     gene_counter < 2;\n"
"			     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"			{\n"
"				// Using randnum[7..8]\n"
"				covr_point[gene_counter] = (int) ((dockpars_num_of_genes-1)*randnums[7+gene_counter]);\n"
"			}\n"
"\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"			\n"
"			// covr_point[0] should store the lower crossover-point\n"
"			if (tidx == 0) {\n"
"				if (covr_point[1] < covr_point[0]) {\n"
"					temp_covr_point = covr_point[1];\n"
"					covr_point[1]   = covr_point[0];\n"
"					covr_point[0]   = temp_covr_point;\n"
"				}\n"
"			}\n"
"\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			for (gene_counter = tidx;\n"
"			     gene_counter < dockpars_num_of_genes;\n"
"			     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"			{\n"
"				// Two-point crossover\n"
"				if (covr_point[0] != covr_point[1]) \n"
"				{\n"
"					if ((gene_counter <= covr_point[0]) || (gene_counter > covr_point[1]))\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[0])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"					else\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[1])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"				}\n"
"				// Single-point crossover\n"
"				else\n"
"				{\n"
"					if (gene_counter <= covr_point[0])\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[0])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"					else\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[1])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"				}\n"
"			}\n"
"\n"
"		}\n"
"		else // no crossover\n"
"		{\n"
"			event_t ev = async_work_group_copy(offspring_genotype,\n"
"			                                   dockpars_conformations_current+(run_id*dockpars_pop_size+parents[0])*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"			                                   dockpars_num_of_genes, 0);\n"
"			// Asynchronous copy should be finished by here\n"
"			wait_group_events(1, &ev);\n"
"		} // End of crossover\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// Performing mutation\n"
"#ifdef GA_MUTATION_TEST\n"
"		float rot_scale = native_sqrt(native_divide((float)dockpars_num_of_genes,(float)dockpars_num_of_atoms));\n"
"#endif\n"
"		for (gene_counter = tidx;\n"
"		     gene_counter < dockpars_num_of_genes;\n"
"		     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			// Notice: dockpars_mutation_rate was scaled down to [0,1] in host\n"
"			// to reduce number of operations in device\n"
"			if (/*100.0f**/gpu_randf(dockpars_prng_states) < dockpars_mutation_rate)\n"
"			{\n"
"#ifdef GA_MUTATION_TEST\n"
"				float pmone = (2.0f*gpu_randf(dockpars_prng_states)-1.0f);\n"
"\n"
"				// Translation genes\n"
"				if (gene_counter < 3) {\n"
"					offspring_genotype[gene_counter] += pmone * dockpars_abs_max_dmov;\n"
"				}\n"
"				// Orientation and torsion genes\n"
"				else {\n"
"					if (gene_counter < 6) {\n"
"						offspring_genotype[gene_counter] += pmone * dockpars_abs_max_dang * rot_scale;\n"
"					} else {\n"
"						offspring_genotype[gene_counter] += pmone * dockpars_abs_max_dang;\n"
"					}\n"
"					map_angle(&(offspring_genotype[gene_counter]));\n"
"				}\n"
"#else\n"
"				// Translation genes\n"
"				if (gene_counter < 3) {\n"
"					offspring_genotype[gene_counter] += dockpars_abs_max_dmov*(2*gpu_randf(dockpars_prng_states)-1);\n"
"				}\n"
"				// Orientation and torsion genes\n"
"				else {\n"
"					offspring_genotype[gene_counter] += dockpars_abs_max_dang*(2*gpu_randf(dockpars_prng_states)-1);\n"
"					map_angle(&(offspring_genotype[gene_counter]));\n"
"				}\n"
"#endif\n"
"			}\n"
"		} // End of mutation\n"
"\n"
"		// Calculating energy of new offspring\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// =============================================================\n"
"		gpu_calc_energy(dockpars_rotbondlist_length,\n"
"		                dockpars_num_of_atoms,\n"
"		                dockpars_true_ligand_atoms,\n"
"		                dockpars_gridsize_x,\n"
"		                dockpars_gridsize_y,\n"
"		                dockpars_gridsize_z,\n"
"		                                                     // g1 = gridsize_x\n"
"		                dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"		                dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"		                dockpars_fgrids,\n"
"		                dockpars_num_of_atypes,\n"
"		                dockpars_num_of_map_atypes,\n"
"		                dockpars_num_of_intraE_contributors,\n"
"		                dockpars_grid_spacing,\n"
"		                dockpars_coeff_elec,\n"
"		                dockpars_elec_min_distance,\n"
"		                dockpars_qasp,\n"
"		                dockpars_coeff_desolv,\n"
"		                dockpars_smooth,\n"
"		                offspring_genotype,\n"
"		                &energy,\n"
"		                &run_id,\n"
"		                // Some OpenCL compilers don't allow declaring\n"
"		                // local variables within non-kernel functions.\n"
"		                // These local variables must be declared in a kernel,\n"
"		                // and then passed to non-kernel functions.\n"
"		                calc_coords,\n"
"		                partial_energies,\n"
"		                #if defined (DEBUG_ENERGY_KERNEL)\n"
"		                partial_interE,\n"
"		                partial_intraE,\n"
"		                #endif\n"
"#if 0\n"
"		                false,\n"
"#endif\n"
"		                kerconst_interintra,\n"
"		                kerconst_intracontrib,\n"
"		                kerconst_intra,\n"
"		                kerconst_rotlist,\n"
"		                kerconst_conform\n"
"		               );\n"
"		// =============================================================\n"
"\n"
"		if (tidx == 0) {\n"
"			dockpars_evals_of_new_entities[get_group_id(0)] = 1;\n"
"			dockpars_energies_next[get_group_id(0)] = energy;\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL4)\n"
"			printf(\"%-18s [%-5s]---{%-5s}   [%-10.8f]---{%-10.8f}\\n\", \"-ENERGY-KERNEL4-\", \"GRIDS\", \"INTRA\", partial_interE[0], partial_intraE[0]);\n"
"			#endif\n"
"		}\n"
"\n"
"		// Copying new offspring to next generation\n"
"		event_t ev2 = async_work_group_copy(dockpars_conformations_next + GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0),\n"
"		                                    offspring_genotype,\n"
"		                                    dockpars_num_of_genes, 0);\n"
"\n"
"		// Asynchronous copy should be finished by here\n"
"		wait_group_events(1, &ev2);\n"
"  }\n"
"}\n"
"/*\n"
"\n"
"AutoDock-GPU, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"For some of the code, Copyright (C) 2019 Computational Structural Biology Center, the Scripps Research Institute.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This library is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU Lesser General Public\n"
"License as published by the Free Software Foundation; either\n"
"version 2.1 of the License, or (at your option) any later version.\n"
"\n"
"This library is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"Lesser General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU Lesser General Public\n"
"License along with this library; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n"
"\n"
"*/\n"
"\n"
"\n"
"// if defined, new (experimental) SW genotype moves that are dependent\n"
"// on nr of atoms and nr of torsions of ligand are used\n"
"#define SWAT3 // Third set of Solis-Wets hyperparameters by Andreas Tillack\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"perform_LS(\n"
"                 int    dockpars_num_of_atoms,\n"
"                 int    dockpars_true_ligand_atoms,\n"
"                 int    dockpars_num_of_atypes,\n"
"                 int    dockpars_num_of_map_atypes,\n"
"                 int    dockpars_num_of_intraE_contributors,\n"
"                 int    dockpars_gridsize_x,\n"
"                 int    dockpars_gridsize_y,\n"
"                 int    dockpars_gridsize_z,\n"
"                                                             // g1 = gridsize_x\n"
"                 uint   dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"                 uint   dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"                 float  dockpars_grid_spacing,\n"
"  __global const float* restrict dockpars_fgrids, // This is too large to be allocated in __constant\n"
"                 int    dockpars_rotbondlist_length,\n"
"                 float  dockpars_coeff_elec,\n"
"                 float  dockpars_elec_min_distance,\n"
"                 float  dockpars_coeff_desolv,\n"
"  __global       float* restrict dockpars_conformations_next,\n"
"  __global       float* restrict dockpars_energies_next,\n"
"  __global       int*   restrict dockpars_evals_of_new_entities,\n"
"  __global       uint*  restrict dockpars_prng_states,\n"
"                 int    dockpars_pop_size,\n"
"                 int    dockpars_num_of_genes,\n"
"                 float  dockpars_lsearch_rate,\n"
"                 uint   dockpars_num_of_lsentities,\n"
"                 float  dockpars_rho_lower_bound,\n"
"                 float  dockpars_base_dmov_mul_sqrt3,\n"
"                 float  dockpars_base_dang_mul_sqrt3,\n"
"                 uint   dockpars_cons_limit,\n"
"                 uint   dockpars_max_num_of_iters,\n"
"                 float  dockpars_qasp,\n"
"                 float  dockpars_smooth,\n"
"\n"
"__constant       kernelconstant_interintra*   kerconst_interintra,\n"
"  __global const kernelconstant_intracontrib* kerconst_intracontrib,\n"
"__constant       kernelconstant_intra*        kerconst_intra,\n"
"__constant       kernelconstant_rotlist*      kerconst_rotlist,\n"
"__constant       kernelconstant_conform*      kerconst_conform\n"
"          )\n"
"// The GPU global function performs local search on the pre-defined entities of conformations_next.\n"
"// The number of blocks which should be started equals to num_of_lsentities*num_of_runs.\n"
"// This way the first num_of_lsentities entity of each population will be subjected to local search\n"
"// (and each block carries out the algorithm for one entity).\n"
"// Since the first entity is always the best one in the current population,\n"
"// it is always tested according to the ls probability, and if it not to be\n"
"// subjected to local search, the entity with ID num_of_lsentities is selected instead of the first one (with ID 0).\n"
"{\n"
"	// Some OpenCL compilers don't allow declaring\n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel,\n"
"	// and then passed to non-kernel functions.\n"
"	__local float genotype_candidate[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float genotype_deviate  [ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float genotype_bias     [ACTUAL_GENOTYPE_LENGTH];\n"
"        __local float rho;\n"
"	__local uint  cons_succ;\n"
"	__local uint  cons_fail;\n"
"	__local uint  iteration_cnt;\n"
"	__local float candidate_energy;\n"
"	__local int   evaluation_cnt;\n"
"	int gene_counter;\n"
"	int gene_start = (dockpars_true_ligand_atoms==0)*6;\n"
"\n"
"	__local float offspring_genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local int run_id;\n"
"	__local int entity_id;\n"
"	__local float offspring_energy;\n"
"\n"
"	__local float4 calc_coords[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	#if defined (DEBUG_ENERGY_KERNEL)\n"
"	__local float partial_interE [NUM_OF_THREADS_PER_BLOCK];\n"
"	__local float partial_intraE [NUM_OF_THREADS_PER_BLOCK];\n"
"	#endif\n"
"\n"
"	int tidx = get_local_id(0);\n"
"	// Determining run ID and entity ID\n"
"	// Initializing offspring genotype\n"
"	if (tidx == 0)\n"
"	{\n"
"		run_id = get_group_id(0) / dockpars_num_of_lsentities;\n"
"		entity_id = get_group_id(0) - run_id * dockpars_num_of_lsentities;\n"
"\n"
"		// Since entity 0 is the best one due to elitism,\n"
"		// it should be subjected to random selection\n"
"		if (entity_id == 0) {\n"
"			// If entity 0 is not selected according to LS-rate,\n"
"			// choosing an other entity\n"
"			if (100.0f*gpu_randf(dockpars_prng_states) > dockpars_lsearch_rate) {\n"
"				entity_id = dockpars_num_of_lsentities;\n"
"			}\n"
"		}\n"
"\n"
"		offspring_energy = dockpars_energies_next[run_id*dockpars_pop_size+entity_id];\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	event_t ev = async_work_group_copy(offspring_genotype,\n"
"	                                   dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"	                                   dockpars_num_of_genes, 0);\n"
"\n"
"	for (gene_counter = tidx;\n"
"	     gene_counter < dockpars_num_of_genes;\n"
"	     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		genotype_bias[gene_counter] = 0.0f;\n"
"	}\n"
"\n"
"	if (tidx == 0) {\n"
"		rho = 1.0f;\n"
"		cons_succ = 0;\n"
"		cons_fail = 0;\n"
"		iteration_cnt = 0;\n"
"		evaluation_cnt = 0;\n"
"	}\n"
"\n"
"\n"
"	// Asynchronous copy should be finished by here\n"
"	wait_group_events(1, &ev);\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"#ifdef SWAT3\n"
"	float lig_scale = 1.0f/sqrt((float)dockpars_num_of_atoms);\n"
"	float gene_scale = 1.0f/sqrt((float)dockpars_num_of_genes);\n"
"#endif\n"
"	while ((iteration_cnt < dockpars_max_num_of_iters) && (rho > dockpars_rho_lower_bound))\n"
"	{\n"
"		// New random deviate\n"
"		for (gene_counter = tidx+gene_start;\n"
"		     gene_counter < dockpars_num_of_genes;\n"
"		     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"#ifdef SWAT3\n"
"			genotype_deviate[gene_counter] = rho * (2.0f*gpu_randf(dockpars_prng_states)-1.0f) * (gpu_randf(dockpars_prng_states) < gene_scale);\n"
"\n"
"			// Translation genes\n"
"			if (gene_counter < 3) {\n"
"				genotype_deviate[gene_counter] *= dockpars_base_dmov_mul_sqrt3;\n"
"			}\n"
"			// Orientation and torsion genes\n"
"			else {\n"
"				if (gene_counter < 6) {\n"
"					genotype_deviate[gene_counter] *= dockpars_base_dang_mul_sqrt3 * lig_scale;\n"
"				} else {\n"
"					genotype_deviate[gene_counter] *= dockpars_base_dang_mul_sqrt3 * gene_scale;\n"
"				}\n"
"			}\n"
"#else\n"
"			genotype_deviate[gene_counter] = rho*(2.0f*gpu_randf(dockpars_prng_states)-1.0f) * (gpu_randf(dockpars_prng_states) < 0.3f);\n"
"\n"
"			// Translation genes\n"
"			if (gene_counter < 3) {\n"
"				genotype_deviate[gene_counter] *= dockpars_base_dmov_mul_sqrt3;\n"
"			}\n"
"			// Orientation and torsion genes\n"
"			else {\n"
"				genotype_deviate[gene_counter] *= dockpars_base_dang_mul_sqrt3;\n"
"			}\n"
"#endif\n"
"		}\n"
"\n"
"		// Generating new genotype candidate\n"
"		for (gene_counter = tidx+gene_start;\n"
"		     gene_counter < dockpars_num_of_genes;\n"
"		     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			genotype_candidate[gene_counter] = offspring_genotype[gene_counter] +\n"
"			                                   genotype_deviate[gene_counter]   +\n"
"			                                   genotype_bias[gene_counter];\n"
"		}\n"
"\n"
"		// Evaluating candidate\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// ==================================================================\n"
"		gpu_calc_energy( dockpars_rotbondlist_length,\n"
"		                 dockpars_num_of_atoms,\n"
"		                 dockpars_true_ligand_atoms,\n"
"		                 dockpars_gridsize_x,\n"
"		                 dockpars_gridsize_y,\n"
"		                 dockpars_gridsize_z,\n"
"		                                                     // g1 = gridsize_x\n"
"		                 dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"		                 dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"		                 dockpars_fgrids,\n"
"		                 dockpars_num_of_atypes,\n"
"		                 dockpars_num_of_map_atypes,\n"
"		                 dockpars_num_of_intraE_contributors,\n"
"		                 dockpars_grid_spacing,\n"
"		                 dockpars_coeff_elec,\n"
"		                 dockpars_elec_min_distance,\n"
"		                 dockpars_qasp,\n"
"		                 dockpars_coeff_desolv,\n"
"		                 dockpars_smooth,\n"
"		                 genotype_candidate,\n"
"		                 &candidate_energy,\n"
"		                 &run_id,\n"
"		                 // Some OpenCL compilers don't allow declaring\n"
"		                 // local variables within non-kernel functions.\n"
"		                 // These local variables must be declared in a kernel,\n"
"		                 // and then passed to non-kernel functions.\n"
"		                 calc_coords,\n"
"		                 partial_energies,\n"
"		                 #if defined (DEBUG_ENERGY_KERNEL)\n"
"		                 partial_interE,\n"
"		                 partial_intraE,\n"
"		                 #endif\n"
"#if 0\n"
"		                 false,\n"
"#endif\n"
"		                 kerconst_interintra,\n"
"		                 kerconst_intracontrib,\n"
"		                 kerconst_intra,\n"
"		                 kerconst_rotlist,\n"
"		                 kerconst_conform\n"
"		              );\n"
"		// =================================================================\n"
"\n"
"		if (tidx == 0) {\n"
"			evaluation_cnt++;\n"
"			#if defined (DEBUG_ENERGY_KERNEL)\n"
"			printf(\"%-18s [%-5s]---{%-5s}   [%-10.8f]---{%-10.8f}\\n\", \"-ENERGY-KERNEL3-\", \"GRIDS\", \"INTRA\", partial_interE[0], partial_intraE[0]);\n"
"			#endif\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (candidate_energy < offspring_energy) // If candidate is better, success\n"
"		{\n"
"			for (gene_counter = tidx+gene_start;\n"
"			     gene_counter < dockpars_num_of_genes;\n"
"			     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"			{\n"
"				// Updating offspring_genotype\n"
"				offspring_genotype[gene_counter] = genotype_candidate[gene_counter];\n"
"\n"
"				// Updating genotype_bias\n"
"				genotype_bias[gene_counter] = 0.6f*genotype_bias[gene_counter] + 0.4f*genotype_deviate[gene_counter];\n"
"			}\n"
"\n"
"			// Work-item 0 will overwrite the shared variables\n"
"			// used in the previous if condition\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			if (tidx == 0)\n"
"			{\n"
"				offspring_energy = candidate_energy;\n"
"				cons_succ++;\n"
"				cons_fail = 0;\n"
"			}\n"
"		}\n"
"		else // If candidate is worse, check the opposite direction\n"
"		{\n"
"			// Generating the other genotype candidate\n"
"			for (gene_counter = tidx+gene_start;\n"
"			     gene_counter < dockpars_num_of_genes;\n"
"			     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"			{\n"
"				genotype_candidate[gene_counter] = offspring_genotype[gene_counter] -\n"
"				                                   genotype_deviate[gene_counter] -\n"
"				                                   genotype_bias[gene_counter];\n"
"			}\n"
"\n"
"			// Evaluating candidate\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			// =================================================================\n"
"			gpu_calc_energy( dockpars_rotbondlist_length,\n"
"			                 dockpars_num_of_atoms,\n"
"			                 dockpars_true_ligand_atoms,\n"
"			                 dockpars_gridsize_x,\n"
"			                 dockpars_gridsize_y,\n"
"			                 dockpars_gridsize_z,\n"
"			                                                      // g1 = gridsize_x\n"
"			                 dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"			                 dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"			                 dockpars_fgrids,\n"
"			                 dockpars_num_of_atypes,\n"
"			                 dockpars_num_of_map_atypes,\n"
"			                 dockpars_num_of_intraE_contributors,\n"
"			                 dockpars_grid_spacing,\n"
"			                 dockpars_coeff_elec,\n"
"			                 dockpars_elec_min_distance,\n"
"			                 dockpars_qasp,\n"
"			                 dockpars_coeff_desolv,\n"
"			                 dockpars_smooth,\n"
"			                 genotype_candidate,\n"
"			                 &candidate_energy,\n"
"			                 &run_id,\n"
"			                 // Some OpenCL compilers don't allow declaring\n"
"			                 // local variables within non-kernel functions.\n"
"			                 // These local variables must be declared in a kernel,\n"
"			                 // and then passed to non-kernel functions.\n"
"			                 calc_coords,\n"
"			                 partial_energies,\n"
"			                 #if defined (DEBUG_ENERGY_KERNEL)\n"
"			                 partial_interE,\n"
"			                 partial_intraE,\n"
"			                 #endif\n"
"#if 0\n"
"			                 false,\n"
"#endif\n"
"			                 kerconst_interintra,\n"
"			                 kerconst_intracontrib,\n"
"			                 kerconst_intra,\n"
"			                 kerconst_rotlist,\n"
"			                 kerconst_conform\n"
"			               );\n"
"			// =================================================================\n"
"\n"
"			if (tidx == 0) {\n"
"				evaluation_cnt++;\n"
"\n"
"				#if defined (DEBUG_ENERGY_KERNEL)\n"
"				printf(\"%-18s [%-5s]---{%-5s}   [%-10.8f]---{%-10.8f}\\n\", \"-ENERGY-KERNEL3-\", \"GRIDS\", \"INTRA\", partial_interE[0], partial_intraE[0]);\n"
"				#endif\n"
"			}\n"
"\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			if (candidate_energy < offspring_energy) // If candidate is better, success\n"
"			{\n"
"				for (gene_counter = tidx+gene_start;\n"
"				     gene_counter < dockpars_num_of_genes;\n"
"				     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"				{\n"
"					// Updating offspring_genotype\n"
"					offspring_genotype[gene_counter] = genotype_candidate[gene_counter];\n"
"\n"
"					// Updating genotype_bias\n"
"					genotype_bias[gene_counter] = 0.6f*genotype_bias[gene_counter] - 0.4f*genotype_deviate[gene_counter];\n"
"				}\n"
"\n"
"				// Work-item 0 will overwrite the shared variables\n"
"				// used in the previous if condition\n"
"				barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"				if (tidx == 0)\n"
"				{\n"
"					offspring_energy = candidate_energy;\n"
"					cons_succ++;\n"
"					cons_fail = 0;\n"
"				}\n"
"			}\n"
"			else // Failure in both directions\n"
"			{\n"
"				for (gene_counter = tidx+gene_start;\n"
"				     gene_counter < dockpars_num_of_genes;\n"
"				     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"					// Updating genotype_bias\n"
"					genotype_bias[gene_counter] = 0.5f*genotype_bias[gene_counter];\n"
"\n"
"				if (tidx == 0)\n"
"				{\n"
"					cons_succ = 0;\n"
"					cons_fail++;\n"
"				}\n"
"			}\n"
"		}\n"
"\n"
"		// Changing rho if needed\n"
"		if (tidx == 0)\n"
"		{\n"
"			iteration_cnt++;\n"
"\n"
"			if (cons_succ >= dockpars_cons_limit)\n"
"			{\n"
"				rho *= LS_EXP_FACTOR;\n"
"				cons_succ = 0;\n"
"			}\n"
"			else\n"
"				if (cons_fail >= dockpars_cons_limit)\n"
"				{\n"
"					rho *= LS_CONT_FACTOR;\n"
"					cons_fail = 0;\n"
"				}\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"	}\n"
"\n"
"	// Updating eval counter and energy\n"
"	if (tidx == 0) {\n"
"		dockpars_evals_of_new_entities[run_id*dockpars_pop_size+entity_id] += evaluation_cnt;\n"
"		dockpars_energies_next[run_id*dockpars_pop_size+entity_id] = offspring_energy;\n"
"	}\n"
"\n"
"	// Mapping torsion angles\n"
"	for (gene_counter = tidx+3;\n"
"	     gene_counter < dockpars_num_of_genes;\n"
"	     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		map_angle(&(offspring_genotype[gene_counter]));\n"
"	}\n"
"\n"
"	// Updating old offspring in population\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	event_t ev2 = async_work_group_copy(dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"	                                    offspring_genotype,\n"
"	                                    dockpars_num_of_genes,0);\n"
"\n"
"	// Asynchronous copy should be finished by here\n"
"	wait_group_events(1, &ev2);\n"
"}\n"
"/*\n"
"\n"
"AutoDock-GPU, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"For some of the code, Copyright (C) 2019 Computational Structural Biology Center, the Scripps Research Institute.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This library is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU Lesser General Public\n"
"License as published by the Free Software Foundation; either\n"
"version 2.1 of the License, or (at your option) any later version.\n"
"\n"
"This library is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"Lesser General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU Lesser General Public\n"
"License along with this library; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n"
"\n"
"*/\n"
"\n"
"\n"
"// Gradient-based steepest descent minimizer\n"
"// Alternative to Solis-Wets\n"
"\n"
"//#define DEBUG_ENERGY_KERNEL5\n"
"//#define PRINT_ENERGIES\n"
"//#define PRINT_GENES_AND_GRADS\n"
"//#define PRINT_ATOMIC_COORDS\n"
"\n"
"// Enable DEBUG_MINIMIZER for a seeing a detailed SD evolution\n"
"// If only PRINT_MINIMIZER_ENERGY_EVOLUTION is enabled,\n"
"// then a only a simplified SD evolution will be shown\n"
"//#define DEBUG_MINIMIZER\n"
"//#define PRINT_MINIMIZER_ENERGY_EVOLUTION\n"
"\n"
"// Enable this for debugging SD from a defined initial genotype\n"
"//#define DEBUG_INITIAL_2BRT\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gradient_minSD(\n"
"                     int    dockpars_num_of_atoms,\n"
"                     int    dockpars_true_ligand_atoms,\n"
"                     int    dockpars_num_of_atypes,\n"
"                     int    dockpars_num_of_map_atypes,\n"
"                     int    dockpars_num_of_intraE_contributors,\n"
"                     int    dockpars_gridsize_x,\n"
"                     int    dockpars_gridsize_y,\n"
"                     int    dockpars_gridsize_z,\n"
"                                                                 // g1 = gridsize_x\n"
"                     uint   dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"                     uint   dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"                     float  dockpars_grid_spacing,\n"
"      __global const float* restrict dockpars_fgrids, // This is too large to be allocated in __constant\n"
"                     int    dockpars_rotbondlist_length,\n"
"                     float  dockpars_coeff_elec,\n"
"                     float  dockpars_elec_min_distance,\n"
"                     float  dockpars_coeff_desolv,\n"
"      __global       float* restrict dockpars_conformations_next,\n"
"      __global       float* restrict dockpars_energies_next,\n"
"      __global       int*   restrict dockpars_evals_of_new_entities,\n"
"      __global       uint*  restrict dockpars_prng_states,\n"
"                     int    dockpars_pop_size,\n"
"                     int    dockpars_num_of_genes,\n"
"                     float  dockpars_lsearch_rate,\n"
"                     uint   dockpars_num_of_lsentities,\n"
"                     uint   dockpars_max_num_of_iters,\n"
"                     float  dockpars_qasp,\n"
"                     float  dockpars_smooth,\n"
"\n"
"    __constant       kernelconstant_interintra*   kerconst_interintra,\n"
"      __global const kernelconstant_intracontrib* kerconst_intracontrib,\n"
"    __constant       kernelconstant_intra*        kerconst_intra,\n"
"    __constant       kernelconstant_rotlist*      kerconst_rotlist,\n"
"    __constant       kernelconstant_conform*      kerconst_conform,\n"
"\n"
"    __constant       int*   rotbonds_const,\n"
"      __global const int*   rotbonds_atoms_const,\n"
"    __constant       int*   num_rotating_atoms_per_rotbond_const\n"
"              )\n"
"// The GPU global function performs gradient-based minimization on (some) entities of conformations_next.\n"
"// The number of OpenCL compute units (CU) which should be started equals to num_of_minEntities*num_of_runs.\n"
"// This way the first num_of_lsentities entity of each population will be subjected to local search\n"
"// (and each CU carries out the algorithm for one entity).\n"
"// Since the first entity is always the best one in the current population,\n"
"// it is always tested according to the ls probability, and if it not to be\n"
"// subjected to local search, the entity with ID num_of_lsentities is selected instead of the first one (with ID 0).\n"
"{\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"\n"
"	// Determining entity, and its run, energy, and genotype\n"
"	__local int   entity_id;\n"
"	__local int   run_id;\n"
"	__local float energy;\n"
"	__local float genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	// Iteration counter fot the minimizer\n"
"	__local uint iteration_cnt;\n"
"\n"
"	// Stepsize for the minimizer\n"
"	__local float stepsize;\n"
"\n"
"	int tidx = get_local_id(0);\n"
"	if (tidx == 0)\n"
"	{\n"
"		// Choosing a random entity out of the entire population\n"
"		/*\n"
"		run_id = get_group_id(0);\n"
"		//entity_id = (uint)(dockpars_pop_size * gpu_randf(dockpars_prng_states));\n"
"		entity_id = 0;\n"
"		*/\n"
"\n"
"		run_id = get_group_id(0) / dockpars_num_of_lsentities;\n"
"		entity_id = get_group_id(0) % dockpars_num_of_lsentities;\n"
"\n"
"		// Since entity 0 is the best one due to elitism,\n"
"		// it should be subjected to random selection\n"
"		if (entity_id == 0) {\n"
"			// If entity 0 is not selected according to LS-rate,\n"
"			// choosing an other entity\n"
"			if (100.0f*gpu_randf(dockpars_prng_states) > dockpars_lsearch_rate) {\n"
"				entity_id = dockpars_num_of_lsentities;\n"
"			}\n"
"		}\n"
"		\n"
"		energy = dockpars_energies_next[run_id*dockpars_pop_size+entity_id];\n"
"\n"
"		// Initializing gradient-minimizer counters and flags\n"
"		iteration_cnt  = 0;\n"
"		stepsize       = STEP_START;\n"
"\n"
"		#if defined (DEBUG_MINIMIZER) || defined (PRINT_MINIMIZER_ENERGY_EVOLUTION)\n"
"		printf(\"\\n\");\n"
"		printf(\"-------> Start of SD minimization cycle\\n\");\n"
"		printf(\"%20s %6u\\n\", \"run_id: \", run_id);\n"
"		printf(\"%20s %6u\\n\", \"entity_id: \", entity_id);\n"
"		printf(\"\\n\");\n"
"		printf(\"%20s \\n\", \"LGA genotype: \");\n"
"		printf(\"%20s %.6f\\n\", \"initial energy: \", energy);\n"
"		printf(\"%20s %.6f\\n\", \"initial stepsize: \", stepsize);\n"
"		#endif\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	event_t ev = async_work_group_copy(genotype,\n"
"	                                   dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"	                                   dockpars_num_of_genes, 0);\n"
"	// Asynchronous copy should be finished by here\n"
"	wait_group_events(1, &ev);\n"
"\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"	\n"
"	// Partial results of the gradient step\n"
"	__local float gradient          [ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float candidate_energy;\n"
"	__local float candidate_genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	// -------------------------------------------------------------------\n"
"	// Calculate gradients (forces) for intermolecular energy\n"
"	// Derived from autodockdev/maps.py\n"
"	// -------------------------------------------------------------------\n"
"	// Gradient of the intermolecular energy per each ligand atom\n"
"	// Also used to store the accummulated gradient per each ligand atom\n"
"	__local float gradient_x[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_y[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_z[MAX_NUM_OF_ATOMS];\n"
"\n"
"	__local float f_gradient_x[MAX_NUM_OF_ATOMS];\n"
"	__local float f_gradient_y[MAX_NUM_OF_ATOMS];\n"
"	__local float f_gradient_z[MAX_NUM_OF_ATOMS];\n"
"\n"
"	// Ligand-atom position and partial energies\n"
"	__local float4 calc_coords[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	#if defined (DEBUG_ENERGY_KERNEL)\n"
"	__local float partial_interE[NUM_OF_THREADS_PER_BLOCK];\n"
"	__local float partial_intraE[NUM_OF_THREADS_PER_BLOCK];\n"
"	#endif\n"
"\n"
"	// Enable this for debugging SD from a defined initial genotype\n"
"	#if defined (DEBUG_INITIAL_2BRT)\n"
"	if (tidx == 0) {\n"
"		// 2brt\n"
"		genotype[0] = 24.093334f;\n"
"		genotype[1] = 24.658667f;\n"
"		genotype[2] = 24.210667f;\n"
"		genotype[3] = 50.0f;\n"
"		genotype[4] = 50.0f;\n"
"		genotype[5] = 50.0f;\n"
"		genotype[6] = 0.0f;\n"
"		genotype[7] = 0.0f;\n"
"		genotype[8] = 0.0f;\n"
"		genotype[9] = 0.0f;\n"
"		genotype[10] = 0.0f;\n"
"		genotype[11] = 0.0f;\n"
"		genotype[12] = 0.0f;\n"
"		genotype[13] = 0.0f;\n"
"		genotype[14] = 0.0f;\n"
"		genotype[15] = 0.0f;\n"
"		genotype[16] = 0.0f;\n"
"		genotype[17] = 0.0f;\n"
"		genotype[18] = 0.0f;\n"
"		genotype[19] = 0.0f;\n"
"		genotype[20] = 0.0f;\n"
"	}\n"
"	// Evaluating candidate\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// =============================================================\n"
"	gpu_calc_energy(dockpars_rotbondlist_length,\n"
"	                dockpars_num_of_atoms,\n"
"	                dockpars_true_ligand_atoms,\n"
"	                dockpars_gridsize_x,\n"
"	                dockpars_gridsize_y,\n"
"	                dockpars_gridsize_z,\n"
"	                                                     // g1 = gridsize_x\n"
"	                dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"	                dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"	                dockpars_fgrids,\n"
"	                dockpars_num_of_atypes,\n"
"	                dockpars_num_of_map_atypes,\n"
"	                dockpars_num_of_intraE_contributors,\n"
"	                dockpars_grid_spacing,\n"
"	                dockpars_coeff_elec,\n"
"	                dockpars_elec_min_distance,\n"
"	                dockpars_qasp,\n"
"	                dockpars_coeff_desolv,\n"
"	                dockpars_smooth,\n"
"	\n"
"	                genotype, /*WARNING: calculating the energy of the hardcoded genotype*/\n"
"	                &energy,\n"
"	                &run_id,\n"
"	                // Some OpenCL compilers don't allow declaring\n"
"	                // local variables within non-kernel functions.\n"
"	                // These local variables must be declared in a kernel,\n"
"	                // and then passed to non-kernel functions.\n"
"	                calc_coords,\n"
"	                partial_energies,\n"
"	                #if defined (DEBUG_ENERGY_KERNEL)\n"
"	                partial_interE,\n"
"	                partial_intraE,\n"
"	                #endif\n"
"#if 0\n"
"	                true,\n"
"#endif\n"
"	                kerconst_interintra,\n"
"	                kerconst_intracontrib,\n"
"	                kerconst_intra,\n"
"	                kerconst_rotlist,\n"
"	                kerconst_conform\n"
"	               );\n"
"	// =============================================================\n"
"\n"
"	// WARNING: hardcoded has priority over LGA genotype.\n"
"	// That means, if DEBUG_INITIAL_2BRT is defined, then\n"
"	// LGA genotype is not used (only for debugging purposes)\n"
"	if (tidx == 0)\n"
"	{\n"
"		printf(\"\\n\");\n"
"		printf(\"%20s \\n\", \"hardcoded genotype: \");\n"
"		printf(\"%20s %.6f\\n\", \"initial energy: \", energy);\n"
"		printf(\"%20s %.6f\\n\\n\", \"initial stepsize: \", stepsize);\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	#endif\n"
"\n"
"	// Perform gradient-descent iterations\n"
"\n"
"	#if 0\n"
"	// 7cpa\n"
"	float grid_center_x = 49.836f;\n"
"	float grid_center_y = 17.609f;\n"
"	float grid_center_z = 36.272f;\n"
"	float ligand_center_x = 49.2216976744186f;\n"
"	float ligand_center_y = 17.793953488372097f;\n"
"	float ligand_center_z = 36.503837209302326f;\n"
"	float shoemake_gene_u1 = 0.02f;\n"
"	float shoemake_gene_u2 = 0.23f;\n"
"	float shoemake_gene_u3 = 0.95f;\n"
"	#endif\n"
"\n"
"	#if 0\n"
"	// 3tmn\n"
"	float grid_center_x = 52.340f;\n"
"	float grid_center_y = 15.029f;\n"
"	float grid_center_z = -2.932f;\n"
"	float ligand_center_x = 52.22740741f;\n"
"	float ligand_center_y = 15.51751852f;\n"
"	float ligand_center_z = -2.40896296f;\n"
"	#endif\n"
"\n"
"	// Calculating maximum possible stepsize (alpha)\n"
"	__local float max_trans_grad, max_rota_grad, max_tors_grad;\n"
"	__local float max_trans_stepsize, max_rota_stepsize, max_tors_stepsize;\n"
"	__local float max_stepsize;\n"
"\n"
"	// Storing torsion gradients here\n"
"	__local float torsions_gradient[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	// The termination criteria is based on\n"
"	// a maximum number of iterations, and\n"
"	// the minimum step size allowed for single-floating point numbers\n"
"	// (IEEE-754 single float has a precision of about 6 decimal digits)\n"
"	do {\n"
"		#if 0\n"
"		// Specific input genotypes for a ligand with no rotatable bonds (1ac8).\n"
"		// Translation genes must be expressed in grids in AutoDock-GPU (genotype [0|1|2]).\n"
"		// However, for testing purposes, \n"
"		// we start using translation values in real space (Angstrom): {31.79575, 93.743875, 47.699875}\n"
"		// Rotation genes are expresed in the Shoemake space: genotype [3|4|5]\n"
"		// xyz_gene_gridspace = gridcenter_gridspace + (input_gene_realspace - gridcenter_realspace)/gridsize\n"
"\n"
"		// 1ac8\n"
"		genotype[0] = 30f + (31.79575f  - 31.924f) / dockpars_grid_spacing;\n"
"		genotype[1] = 30f + (93.743875f - 93.444f) / dockpars_grid_spacing;\n"
"		genotype[2] = 30f + (47.699875f - 47.924f) / dockpars_grid_spacing;\n"
"		genotype[3] = 0.1f;\n"
"		genotype[4] = 0.5f;\n"
"		genotype[5] = 0.9f;\n"
"		#endif\n"
"\n"
"		#if 0\n"
"		// 3tmn\n"
"		genotype[0] = 30f + (ligand_center_x - grid_center_x) / dockpars_grid_spacing;\n"
"		genotype[1] = 30f + (ligand_center_y - grid_center_y) / dockpars_grid_spacing;\n"
"		genotype[2] = 30f + (ligand_center_z - grid_center_z) / dockpars_grid_spacing;\n"
"		genotype[3] = shoemake_gene_u1;\n"
"		genotype[4] = shoemake_gene_u2;\n"
"		genotype[5] = shoemake_gene_u3;\n"
"		genotype[6] = 0.0f;\n"
"		genotype[7] = 0.0f;\n"
"		genotype[8] = 0.0f;\n"
"		genotype[9] = 0.0f;\n"
"		genotype[10] = 0.0f;\n"
"		genotype[11] = 0.0f;\n"
"		genotype[12] = 0.0f;\n"
"		genotype[13] = 0.0f;\n"
"		genotype[14] = 0.0f;\n"
"		genotype[15] = 0.0f;\n"
"		genotype[16] = 0.0f;\n"
"		genotype[17] = 0.0f;\n"
"		genotype[18] = 0.0f;\n"
"		genotype[19] = 0.0f;\n"
"		genotype[20] = 0.0f;\n"
"		#endif\n"
"\n"
"		#if 0\n"
"		// 2j5s\n"
"		genotype[0] = 28.464f;\n"
"		genotype[1] = 25.792762f;\n"
"		genotype[2] = 23.740571f;\n"
"		genotype[3] = 50.0f;\n"
"		genotype[4] = 50.0f;\n"
"		genotype[5] = 50.0f;\n"
"		genotype[6] = 0.0f;\n"
"		genotype[7] = 0.0f;\n"
"		genotype[8] = 0.0f;\n"
"		genotype[9] = 0.0f;\n"
"		genotype[10] = 0.0f;\n"
"		genotype[11] = 0.0f;\n"
"		genotype[12] = 0.0f;\n"
"		genotype[13] = 0.0f;\n"
"		genotype[14] = 0.0f;\n"
"		genotype[15] = 0.0f;\n"
"		genotype[16] = 0.0f;\n"
"		genotype[17] = 0.0f;\n"
"		genotype[18] = 0.0f;\n"
"		genotype[19] = 0.0f;\n"
"		genotype[20] = 0.0f;\n"
"		#endif\n"
"\n"
"		#if 0\n"
"		// 2brt\n"
"		genotype[0] = 24.093334f;\n"
"		genotype[1] = 24.658667f;\n"
"		genotype[2] = 24.210667f;\n"
"		genotype[3] = 50.0f;\n"
"		genotype[4] = 50.0f;\n"
"		genotype[5] = 50.0f;\n"
"		genotype[6] = 0.0f;\n"
"		genotype[7] = 0.0f;\n"
"		genotype[8] = 0.0f;\n"
"		genotype[9] = 0.0f;\n"
"		genotype[10] = 0.0f;\n"
"		genotype[11] = 0.0f;\n"
"		genotype[12] = 0.0f;\n"
"		genotype[13] = 0.0f;\n"
"		genotype[14] = 0.0f;\n"
"		genotype[15] = 0.0f;\n"
"		genotype[16] = 0.0f;\n"
"		genotype[17] = 0.0f;\n"
"		genotype[18] = 0.0f;\n"
"		genotype[19] = 0.0f;\n"
"		genotype[20] = 0.0f;\n"
"		#endif\n"
"\n"
"		// Printing number of stepest-descent iterations\n"
"		#if defined (DEBUG_MINIMIZER)\n"
"		if (tidx == 0) {\n"
"			printf(\"%s\\n\", \"----------------------------------------------------------\");\n"
"		}\n"
"		#endif\n"
"		\n"
"		#if defined (DEBUG_MINIMIZER) || defined (PRINT_MINIMIZER_ENERGY_EVOLUTION)\n"
"		if (tidx == 0) {\n"
"			printf(\"%-15s %-3u \", \"# SD iteration: \", iteration_cnt);\n"
"		}\n"
"		#endif\n"
"\n"
"		// Calculating gradient\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// =============================================================\n"
"		gpu_calc_gradient(dockpars_rotbondlist_length,\n"
"		                  dockpars_num_of_atoms,\n"
"		                  dockpars_true_ligand_atoms,\n"
"		                  dockpars_gridsize_x,\n"
"		                  dockpars_gridsize_y,\n"
"		                  dockpars_gridsize_z,\n"
"		                                                       // g1 = gridsize_x\n"
"		                  dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"		                  dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"		                  dockpars_fgrids,\n"
"		                  dockpars_num_of_atypes,\n"
"		                  dockpars_num_of_map_atypes,\n"
"		                  dockpars_num_of_intraE_contributors,\n"
"		                  dockpars_grid_spacing,\n"
"		                  dockpars_coeff_elec,\n"
"		                  dockpars_elec_min_distance,\n"
"		                  dockpars_qasp,\n"
"		                  dockpars_coeff_desolv,\n"
"		                  dockpars_smooth,\n"
"		                  // Some OpenCL compilers don't allow declaring\n"
"		                  // local variables within non-kernel functions.\n"
"		                  // These local variables must be declared in a kernel,\n"
"		                  // and then passed to non-kernel functions.\n"
"		                  genotype,\n"
"		                  &energy,\n"
"		                  &run_id,\n"
"		                  calc_coords,\n"
"		                  kerconst_interintra,\n"
"		                  kerconst_intracontrib,\n"
"		                  kerconst_intra,\n"
"		                  kerconst_rotlist,\n"
"		                  kerconst_conform,\n"
"		                  rotbonds_const,\n"
"		                  rotbonds_atoms_const,\n"
"		                  num_rotating_atoms_per_rotbond_const,\n"
"		                  // Gradient-related arguments\n"
"		                  dockpars_num_of_genes,\n"
"		                  gradient_x, gradient_y, gradient_z,\n"
"		                  f_gradient_x, f_gradient_y, f_gradient_z,\n"
"		                  gradient\n"
"		                 );\n"
"		// =============================================================\n"
"\n"
"		// This could be enabled back for double checking\n"
"		#if 0\n"
"		#if defined (DEBUG_ENERGY_KERNEL5)\n"
"		if (/*(get_group_id(0) == 0) &&*/ (tidx == 0)) {\n"
"		\n"
"			#if defined (PRINT_GENES_AND_GRADS)\n"
"			for(int i = 0; i < dockpars_num_of_genes; i++) {\n"
"				if (i == 0) {\n"
"					printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"					printf(\"%13s %13s %5s %15s %15s\\n\", \"gene_id\", \"gene.value\", \"|\", \"gene.grad\", \"(autodockdevpy units)\");\n"
"				}\n"
"				printf(\"%13u %13.6f %5s %15.6f %15.6f\\n\", i, genotype[i], \"|\", gradient[i], (i<3)? (gradient[i]/dockpars_grid_spacing):(gradient[i]*180.0f/PI_FLOAT));\n"
"			}\n"
"			#endif\n"
"\n"
"			#if defined (PRINT_ATOMIC_COORDS)\n"
"			for(int i = 0; i < dockpars_num_of_atoms; i++) {\n"
"				if (i == 0) {\n"
"					printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"					printf(\"%s\\n\", \"Coordinates calculated by calcgradient.cl\");\n"
"					printf(\"%12s %12s %12s %12s\\n\", \"atom_id\", \"coords.x\", \"coords.y\", \"coords.z\");\n"
"				}\n"
"				printf(\"%12u %12.6f %12.6f %12.6f\\n\", i, calc_coords_x[i], calc_coords_y[i], calc_coords_z[i]);\n"
"			}\n"
"			printf(\"\\n\");\n"
"			#endif\n"
"		}\n"
"		#endif\n"
"		#endif\n"
"\n"
"		if (tidx == 0) {\n"
"			// Finding maximum of the absolute value for the three translation gradients\n"
"			max_trans_grad = fmax(fabs(gradient[0]), fabs(gradient[1]));\n"
"			max_trans_grad = fmax(max_trans_grad, fabs(gradient[2]));\n"
"\n"
"			// MAX_DEV_TRANSLATION needs to be expressed in grid size first\n"
"			max_trans_stepsize = native_divide(native_divide(MAX_DEV_TRANSLATION, dockpars_grid_spacing), max_trans_grad);\n"
"\n"
"			// Finding maximum of the absolute value for the three rotation gradients\n"
"			max_rota_grad = fmax(fabs(gradient[3]), fabs(gradient[4]));	\n"
"			max_rota_grad = fmax(max_rota_grad, fabs(gradient[5]));	\n"
"\n"
"			// Note that MAX_DEV_ROTATION is already expressed approprietly\n"
"			max_rota_stepsize = native_divide(MAX_DEV_ROTATION, max_rota_grad);\n"
"		}\n"
"\n"
"		// Copying torsions genes\n"
"		for( int i = tidx;\n"
"		         i < dockpars_num_of_genes-6;\n"
"		         i+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			torsions_gradient[i] = fabs(gradient[i+6]);\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// Calculating maximum absolute torsional gene\n"
"		// https://stackoverflow.com/questions/36465581/opencl-find-max-in-array\n"
"		for (int i=(dockpars_num_of_genes-6)/2; i>=1; i/=2){\n"
"			if (tidx < i) {\n"
"			// This could be enabled back for details\n"
"			#if 0\n"
"			#if defined (DEBUG_MINIMIZER)\n"
"			printf(\"---====--- %u %u %10.10f %-0.10f\\n\", i, tidx, torsions_gradient[tidx], torsions_gradient[tidx + i]);\n"
"			#endif\n"
"			#endif\n"
"\n"
"				if (torsions_gradient[tidx] < torsions_gradient[tidx + i]) {\n"
"					torsions_gradient[tidx] = torsions_gradient[tidx + i];\n"
"				}\n"
"			}\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"		}\n"
"		if (tidx == 0) {\n"
"			max_tors_grad = torsions_gradient[tidx];\n"
"			max_tors_stepsize = native_divide(MAX_DEV_TORSION, max_tors_grad);\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (tidx == 0) {\n"
"			// Calculating the maximum stepsize using previous three\n"
"			max_stepsize = fmin(max_trans_stepsize, max_rota_stepsize);\n"
"			max_stepsize = fmin(max_stepsize, max_tors_stepsize);\n"
"\n"
"			// Capping the stepsize\n"
"			stepsize = fmin(stepsize, max_stepsize);\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		\n"
"		for(int i = tidx; i < dockpars_num_of_genes; i+= NUM_OF_THREADS_PER_BLOCK) {\n"
"			// Taking step\n"
"			candidate_genotype[i] = genotype[i] - stepsize * gradient[i];\n"
"\n"
"			#if defined (DEBUG_MINIMIZER)\n"
"			if (i == 0) {\n"
"				printf(\"\\n%s\\n\", \"After calculating gradients:\");\n"
"				printf(\"%13s %13s %5s %15s %5s %20s\\n\", \"gene_id\", \"gene\", \"|\", \"grad\", \"|\", \"cand.gene\");\n"
"			}\n"
"			printf(\"%13u %13.6f %5s %15.6f %5s %18.6f\\n\", i, genotype[i], \"|\", gradient[i], \"|\", candidate_genotype[i]);\n"
"\n"
"			if (i == 0) {\n"
"				// This could be enabled back for double checking\n"
"				#if 0\n"
"				for(int i = 0; i < dockpars_num_of_genes; i++) {\n"
"					if (i == 0) {\n"
"						printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"						printf(\"\\n%s\\n\", \"After calculating gradients:\");\n"
"						printf(\"%13s %13s %5s %15s %20s\\n\", \"gene_id\", \"gene\", \"|\", \"grad\", \" grad (devpy units)\");\n"
"					}\n"
"					printf(\"%13u %13.6f %5s %15.6f %18.6f\\n\", i, genotype[i], \"|\", gradient[i], (i<3)? (gradient[i]/dockpars_grid_spacing):(gradient[i]*180.0f/PI_FLOAT));\n"
"				}\n"
"				#endif\n"
"\n"
"				printf(\"\\n\");\n"
"				printf(\"%20s %10.6f\\n\", \"max_trans_grad: \", max_trans_grad);\n"
"				printf(\"%20s %10.6f\\n\", \"max_rota_grad: \", max_rota_grad);\n"
"				printf(\"%20s %10.6f\\n\", \"max_tors_grad: \", max_tors_grad);\n"
"\n"
"				printf(\"\\n\");\n"
"				printf(\"%20s %10.6f\\n\", \"max_trans_stepsize: \", max_trans_stepsize);\n"
"				printf(\"%20s %10.6f\\n\", \"max_rota_stepsize: \" , max_rota_stepsize);\n"
"				printf(\"%20s %10.6f\\n\", \"max_tors_stepsize: \" , max_tors_stepsize);\n"
"\n"
"				printf(\"\\n\");\n"
"				printf(\"%20s %10.6f\\n\", \"max_stepsize: \", max_stepsize);\n"
"				printf(\"%20s %10.6f\\n\", \"stepsize: \", stepsize);\n"
"			}\n"
"			#endif\n"
"		}\n"
"		\n"
"		// Evaluating candidate\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// =============================================================\n"
"		gpu_calc_energy(dockpars_rotbondlist_length,\n"
"		                dockpars_num_of_atoms,\n"
"		                dockpars_true_ligand_atoms,\n"
"		                dockpars_gridsize_x,\n"
"		                dockpars_gridsize_y,\n"
"		                dockpars_gridsize_z,\n"
"		                                                     // g1 = gridsize_x\n"
"		                dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"		                dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"		                dockpars_fgrids,\n"
"		                dockpars_num_of_atypes,\n"
"		                dockpars_num_of_map_atypes,\n"
"		                dockpars_num_of_intraE_contributors,\n"
"		                dockpars_grid_spacing,\n"
"		                dockpars_coeff_elec,\n"
"		                dockpars_elec_min_distance,\n"
"		                dockpars_qasp,\n"
"		                dockpars_coeff_desolv,\n"
"		                dockpars_smooth,\n"
"		\n"
"		                candidate_genotype, /*WARNING: calculating the energy of the hardcoded genotype*/\n"
"		                &candidate_energy,\n"
"		                &run_id,\n"
"		                // Some OpenCL compilers don't allow declaring\n"
"		                // local variables within non-kernel functions.\n"
"		                // These local variables must be declared in a kernel,\n"
"		                // and then passed to non-kernel functions.\n"
"		                calc_coords,\n"
"		                partial_energies,\n"
"		                #if defined (DEBUG_ENERGY_KERNEL)\n"
"		                partial_interE,\n"
"		                partial_intraE,\n"
"		                #endif\n"
"#if 0\n"
"		                true,\n"
"#endif\n"
"		                kerconst_interintra,\n"
"		                kerconst_intracontrib,\n"
"		                kerconst_intra,\n"
"		                kerconst_rotlist,\n"
"		                kerconst_conform\n"
"		               );\n"
"		// =============================================================\n"
"\n"
"		#if defined (DEBUG_ENERGY_KERNEL5)\n"
"		if (/*(get_group_id(0) == 0) &&*/ (tidx == 0)) {\n"
"			#if defined (PRINT_ENERGIES)\n"
"			printf(\"\\n\");\n"
"			printf(\"%-10s %-10.6f \\n\", \"intra: \",  partial_intraE[0]);\n"
"			printf(\"%-10s %-10.6f \\n\", \"grids: \",  partial_interE[0]);\n"
"			printf(\"%-10s %-10.6f \\n\", \"Energy: \", (partial_intraE[0] + partial_interE[0]));\n"
"			#endif\n"
"\n"
"			#if defined (PRINT_GENES_AND_GRADS)\n"
"			for(int i = 0; i < dockpars_num_of_genes; i++) {\n"
"				if (i == 0) {\n"
"					printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"					printf(\"%13s %13s %5s %15s %15s\\n\", \"gene_id\", \"cand-gene.value\"/* \"gene.value\"*/, \"|\", \"gene.grad\", \"(autodockdevpy units)\");\n"
"				}\n"
"				printf(\"%13u %13.6f %5s %15.6f %15.6f\\n\", i, candidate_genotype[i] /*genotype[i]*/, \"|\", gradient[i], (i<3)? (gradient[i]/dockpars_grid_spacing):(gradient[i]*180.0f/PI_FLOAT));\n"
"			}\n"
"			#endif\n"
"\n"
"			#if defined (PRINT_ATOMIC_COORDS)\n"
"			for(int i = 0; i < dockpars_num_of_atoms; i++) {\n"
"				if (i == 0) {\n"
"					printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"					printf(\"%s\\n\", \"Coordinates calculated by calcenergy.cl\");\n"
"					printf(\"%12s %12s %12s %12s\\n\", \"atom_id\", \"coords.x\", \"coords.y\", \"coords.z\");\n"
"				}\n"
"				printf(\"%12u %12.6f %12.6f %12.6f\\n\", i, calc_coords_x[i], calc_coords_y[i], calc_coords_z[i]);\n"
"			}\n"
"			printf(\"\\n\");\n"
"			#endif\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		#endif\n"
"\n"
"		#if defined (DEBUG_MINIMIZER)\n"
"		if (tidx == 0) {\n"
"			printf(\"\\n\");\n"
"			printf(\"%s\\n\", \"After calculating energies:\");\n"
"			printf(\"%13s %5s %15s\\n\", \"energy\", \"|\", \"cand.energy\");\n"
"			printf(\"%13.6f %5s %15.6f\\n\", energy, \"|\", candidate_energy);\n"
"			printf(\"\\n\");\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		#endif\n"
"\n"
"		// Checking if E(candidate_genotype) < E(genotype)\n"
"		if (candidate_energy < energy){\n"
"			for( int i = tidx;\n"
"			         i < dockpars_num_of_genes;\n"
"			         i+= NUM_OF_THREADS_PER_BLOCK)\n"
"			{\n"
"				#if defined (DEBUG_MINIMIZER)\n"
"				//printf(\"(%-3u) %-15.7f %-10.7f %-10.7f %-10.7f\\n\", i, stepsize, genotype[i], gradient[i], candidate_genotype[i]);\n"
"\n"
"				if (i == 0) {\n"
"					printf(\"%s\\n\", \"Energy IMPROVED! ... then update genotype:\");\n"
"					printf(\"%13s %13s %5s %15s\\n\", \"gene_id\", \"old.gene\", \"|\", \"new.gene\");\n"
"				}\n"
"				printf(\"%13u %13.6f %5s %15.6f\\n\", i, genotype[i], \"|\", candidate_genotype[i]);\n"
"\n"
"				#endif\n"
"				if (i == 0) {\n"
"					#if defined (DEBUG_MINIMIZER)\n"
"					printf(\"\\n%s\\n\", \"Energy IMPROVED! ... then increase stepsize and update energy:\");\n"
"					#endif\n"
"\n"
"					// Increase stepsize\n"
"					stepsize *= STEP_INCREASE;\n"
"\n"
"					// Updating energy\n"
"					energy = candidate_energy;\n"
"				}\n"
"\n"
"				// Updating genotype\n"
"				genotype[i] = candidate_genotype[i];\n"
"			}\n"
"		}\n"
"		else {\n"
"			#if defined (DEBUG_MINIMIZER)\n"
"			if (tidx == 0) {\n"
"				printf(\"%s\\n\", \"NO energy improvement! ... then decrease stepsize:\");\n"
"			}\n"
"			#endif\n"
"\n"
"			if (tidx == 0) {\n"
"				stepsize *= STEP_DECREASE;\n"
"			}\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// Updating number of stepest-descent iterations (energy evaluations)\n"
"		if (tidx == 0) {\n"
"			iteration_cnt = iteration_cnt + 1;\n"
"\n"
"			#if defined (DEBUG_MINIMIZER) || defined (PRINT_MINIMIZER_ENERGY_EVOLUTION)\n"
"			printf(\"%20s %10.10f %20s %10.6f\\n\", \"new.stepsize: \", stepsize, \"new.energy: \", energy);\n"
"			#endif\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL5)\n"
"			printf(\"%-18s [%-5s]---{%-5s}   [%-10.7f]---{%-10.7f}\\n\", \"-ENERGY-KERNEL5-\", \"GRIDS\", \"INTRA\", partial_interE[0], partial_intraE[0]);\n"
"			#endif\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	} while ((iteration_cnt < dockpars_max_num_of_iters) && (stepsize > 1E-8f));\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"\n"
"  	// Updating eval counter and energy\n"
"	if (tidx == 0) {\n"
"		dockpars_evals_of_new_entities[run_id*dockpars_pop_size+entity_id] += iteration_cnt;\n"
"		dockpars_energies_next[run_id*dockpars_pop_size+entity_id] = energy;\n"
"\n"
"		#if defined (DEBUG_MINIMIZER) || defined (PRINT_MINIMIZER_ENERGY_EVOLUTION)\n"
"		printf(\"\\n\");\n"
"		printf(\"Termination criteria: ( stepsize <= %10.10f ) OR ( #sd-iters >= %-3u )\\n\", 1E-8, dockpars_max_num_of_iters);\n"
"		printf(\"-------> End of SD minimization cycle, num of energy evals: %u, final energy: %.6f\\n\", iteration_cnt, energy);\n"
"		#endif\n"
"	}\n"
"\n"
"	// Mapping torsion angles\n"
"	for ( int gene_counter = tidx;\n"
"	          gene_counter < dockpars_num_of_genes;\n"
"	          gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		if (gene_counter >= 3) {\n"
"			map_angle(&(genotype[gene_counter]));\n"
"		}\n"
"	}\n"
"\n"
"	// Updating old offspring in population\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	event_t ev2 = async_work_group_copy(dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"	                                    genotype,\n"
"	                                    dockpars_num_of_genes, 0);\n"
"\n"
"	// Asynchronous copy should be finished by here\n"
"	wait_group_events(1, &ev2);\n"
"}\n"
"/*\n"
"\n"
"AutoDock-GPU, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"For some of the code, Copyright (C) 2019 Computational Structural Biology Center, the Scripps Research Institute.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This library is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU Lesser General Public\n"
"License as published by the Free Software Foundation; either\n"
"version 2.1 of the License, or (at your option) any later version.\n"
"\n"
"This library is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"Lesser General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU Lesser General Public\n"
"License along with this library; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n"
"\n"
"*/\n"
"\n"
"\n"
"// Gradient-based fire minimizer\n"
"// FIRE: (F)ast (I)nertial (R)elaxation (E)ngine\n"
"// https://www.math.uni-bielefeld.de/~gaehler/papers/fire.pdf\n"
"// https://doi.org/10.1103/PhysRevLett.97.170201\n"
"// Alternative to Solis-Wets / Steepest-Descent / AdaDelta\n"
"\n"
"// These parameters differ from the original implementation:\n"
"//            - DT_INC is larger          [ larger increments of \"dt\" ]\n"
"//            - DT_DEC is closer to 1.0   [ smaller decrements of \"dt\" ]\n"
"//            - ALPHA_START is larger     [ less inertia ]\n"
"\n"
"// As a result, this implementation is \"less local\" than the original.\n"
"// In other words, it is easier to exit the current local minima and\n"
"// jump to a nearby local minima.\n"
"\n"
"// Fire parameters (TODO: to be moved to header file?)\n"
"#define SUCCESS_MIN      5     // N_min   = 5\n"
"#define DT_INC           1.2f  // f_inc   = 1.1\n"
"#define DT_DEC           0.8f  // f_dec   = 0.5\n"
"#define ALPHA_START      0.2f  // a_start = 0.1\n"
"#define ALPHA_DEC        0.99f // f_a     = 0.99\n"
"\n"
"// Tunable parameters\n"
"// This one tuned by trial and error\n"
"#define DT_MAX           10.0f\n"
"#define DT_MAX_DIV_THREE (DT_MAX / 3.0f)\n"
"\n"
"// New parameter\n"
"// Not in original implementation\n"
"// if \"dt\" becomes smaller than this value, stop optimization\n"
"#define DT_MIN           1e-6f\n"
"\n"
"// Enabling \"DEBUG_ENERGY_FIRE\" requires\n"
"// manually enabling \"DEBUG_ENERGY_KERNEL\" in calcenergy.cl\n"
"//#define DEBUG_ENERGY_FIRE\n"
"//#define PRINT_FIRE_ENERGIES\n"
"//#define PRINT_FIRE_GENES_AND_GRADS\n"
"//#define PRINT_FIRE_ATOMIC_COORDS\n"
"//#define PRINT_FIRE_PARAMETERS\n"
"\n"
"// Enable DEBUG_FIRE_MINIMIZER for a seeing a detailed FIRE evolution\n"
"// If only PRINT_FIRE_MINIMIZER_ENERGY_EVOLUTION is enabled,\n"
"// then a only a simplified FIRE evolution will be shown\n"
"//#define DEBUG_FIRE_MINIMIZER\n"
"//#define PRINT_FIRE_MINIMIZER_ENERGY_EVOLUTION\n"
"\n"
"// Enable this for debugging FIRE from a defined initial genotype\n"
"//#define DEBUG_FIRE_INITIAL_2BRT\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gradient_minFire(\n"
"                       int    dockpars_num_of_atoms,\n"
"                       int    dockpars_true_ligand_atoms,\n"
"                       int    dockpars_num_of_atypes,\n"
"                       int    dockpars_num_of_map_atypes,\n"
"                       int    dockpars_num_of_intraE_contributors,\n"
"                       int    dockpars_gridsize_x,\n"
"                       int    dockpars_gridsize_y,\n"
"                       int    dockpars_gridsize_z,\n"
"                                                                   // g1 = gridsize_x\n"
"                       uint   dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"                       uint   dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"                       float  dockpars_grid_spacing,\n"
"        __global const float* restrict dockpars_fgrids, // This is too large to be allocated in __constant\n"
"                       int    dockpars_rotbondlist_length,\n"
"                       float  dockpars_coeff_elec,\n"
"                       float  dockpars_elec_min_distance,\n"
"                       float  dockpars_coeff_desolv,\n"
"        __global       float* restrict dockpars_conformations_next,\n"
"        __global       float* restrict dockpars_energies_next,\n"
"        __global       int*   restrict dockpars_evals_of_new_entities,\n"
"        __global       uint*  restrict dockpars_prng_states,\n"
"                       int    dockpars_pop_size,\n"
"                       int    dockpars_num_of_genes,\n"
"                       float  dockpars_lsearch_rate,\n"
"                       uint   dockpars_num_of_lsentities,\n"
"                       uint   dockpars_max_num_of_iters,\n"
"                       float  dockpars_qasp,\n"
"                       float  dockpars_smooth,\n"
"\n"
"      __constant       kernelconstant_interintra*   kerconst_interintra,\n"
"        __global const kernelconstant_intracontrib* kerconst_intracontrib,\n"
"      __constant       kernelconstant_intra*        kerconst_intra,\n"
"      __constant       kernelconstant_rotlist*      kerconst_rotlist,\n"
"      __constant       kernelconstant_conform*      kerconst_conform,\n"
"\n"
"      __constant       int*   rotbonds_const,\n"
"        __global const int*   rotbonds_atoms_const,\n"
"      __constant       int*   num_rotating_atoms_per_rotbond_const\n"
"                )\n"
"// The GPU global function performs gradient-based minimization on (some) entities of conformations_next.\n"
"// The number of OpenCL compute units (CU) which should be started equals to num_of_minEntities*num_of_runs.\n"
"// This way the first num_of_lsentities entity of each population will be subjected to local search\n"
"// (and each CU carries out the algorithm for one entity).\n"
"// Since the first entity is always the best one in the current population,\n"
"// it is always tested according to the ls probability, and if it not to be\n"
"// subjected to local search, the entity with ID num_of_lsentities is selected instead of the first one (with ID 0).\n"
"{\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"\n"
"	// Determining entity, and its run, energy, and genotype\n"
"	__local int   entity_id;\n"
"	__local int   run_id;\n"
"	__local float energy;\n"
"	__local float genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	// Iteration counter fot the minimizer\n"
"	__local uint iteration_cnt;\n"
"\n"
"	uint tidx = get_local_id(0);\n"
"	if (tidx == 0)\n"
"	{\n"
"		// Choosing a random entity out of the entire population\n"
"		/*\n"
"		run_id = get_group_id(0);\n"
"		//entity_id = (uint)(dockpars_pop_size * gpu_randf(dockpars_prng_states));\n"
"		entity_id = 0;\n"
"		*/\n"
"\n"
"		run_id = get_group_id(0) / dockpars_num_of_lsentities;\n"
"		entity_id = get_group_id(0) % dockpars_num_of_lsentities;\n"
"\n"
"		// Since entity 0 is the best one due to elitism,\n"
"		// it should be subjected to random selection\n"
"		if (entity_id == 0) {\n"
"			// If entity 0 is not selected according to LS-rate,\n"
"			// choosing an other entity\n"
"			if (100.0f*gpu_randf(dockpars_prng_states) > dockpars_lsearch_rate) {\n"
"				entity_id = dockpars_num_of_lsentities;\n"
"			}\n"
"		}\n"
"		\n"
"		energy = dockpars_energies_next[run_id*dockpars_pop_size+entity_id];\n"
"\n"
"		// Initializing gradient-minimizer counters and flags\n"
"		iteration_cnt  = 0;\n"
"\n"
"		#if defined (DEBUG_FIRE_MINIMIZER) || defined (PRINT_FIRE_MINIMIZER_ENERGY_EVOLUTION)\n"
"		printf(\"\\n\");\n"
"		printf(\"-------> Start of FIRE minimization cycle\\n\");\n"
"		printf(\"%20s %6u\\n\", \"run_id: \", run_id);\n"
"		printf(\"%20s %6u\\n\", \"entity_id: \", entity_id);\n"
"		printf(\"\\n\");\n"
"		printf(\"%20s \\n\", \"LGA genotype: \");\n"
"		printf(\"%20s %.6f\\n\", \"initial energy: \", energy);\n"
"		#endif\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	event_t ev = async_work_group_copy(genotype,\n"
"	                                   dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"	                                   dockpars_num_of_genes, 0);\n"
"	// Asynchronous copy should be finished by here\n"
"	wait_group_events(1, &ev);\n"
"\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"\n"
"	// Partial results of the gradient step\n"
"	__local float gradient[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float candidate_gradient[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	// Energy may go up, so we keep track of the best energy ever calculated.\n"
"	// Then, we return the genotype corresponding \n"
"	// to the best observed energy, i.e. \"best_genotype\"\n"
"	__local float best_energy;\n"
"	__local float best_genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	__local float candidate_energy;\n"
"	__local float candidate_genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	// -------------------------------------------------------------------\n"
"	// Calculate gradients (forces) for intermolecular energy\n"
"	// Derived from autodockdev/maps.py\n"
"	// -------------------------------------------------------------------\n"
"	// Gradient of the intermolecular energy per each ligand atom\n"
"	// Also used to store the accummulated gradient per each ligand atom\n"
"#ifdef FLOAT_GRADIENTS\n"
"	__local float gradient_x[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_y[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_z[MAX_NUM_OF_ATOMS];\n"
"#else\n"
"	__local int   gradient_x[MAX_NUM_OF_ATOMS];\n"
"	__local int   gradient_y[MAX_NUM_OF_ATOMS];\n"
"	__local int   gradient_z[MAX_NUM_OF_ATOMS];\n"
"#endif\n"
"	__local float f_gradient_x[MAX_NUM_OF_ATOMS];\n"
"	__local float f_gradient_y[MAX_NUM_OF_ATOMS];\n"
"	__local float f_gradient_z[MAX_NUM_OF_ATOMS];\n"
"\n"
"	// Ligand-atom position and partial energies\n"
"	__local float4 calc_coords[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	#if defined (DEBUG_ENERGY_KERNEL)\n"
"	__local float partial_interE[NUM_OF_THREADS_PER_BLOCK];\n"
"	__local float partial_intraE[NUM_OF_THREADS_PER_BLOCK];\n"
"	#endif\n"
"\n"
"	// Enable this for debugging FIRE from a defined initial genotype\n"
"	#if defined (DEBUG_FIRE_INITIAL_2BRT)\n"
"	if (tidx == 0) {\n"
"		// 2brt\n"
"		genotype[0]  = 24.093334f;\n"
"		genotype[1]  = 24.658667f;\n"
"		genotype[2]  = 24.210667f;\n"
"		genotype[3]  = 50.0f;\n"
"		genotype[4]  = 50.0f;\n"
"		genotype[5]  = 50.0f;\n"
"		genotype[6]  = 0.0f;\n"
"		genotype[7]  = 0.0f;\n"
"		genotype[8]  = 0.0f;\n"
"		genotype[9]  = 0.0f;\n"
"		genotype[10] = 0.0f;\n"
"		genotype[11] = 0.0f;\n"
"		genotype[12] = 0.0f;\n"
"		genotype[13] = 0.0f;\n"
"		genotype[14] = 0.0f;\n"
"		genotype[15] = 0.0f;\n"
"		genotype[16] = 0.0f;\n"
"		genotype[17] = 0.0f;\n"
"		genotype[18] = 0.0f;\n"
"		genotype[19] = 0.0f;\n"
"		genotype[20] = 0.0f;\n"
"	}\n"
"	// Evaluating candidate\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// =============================================================\n"
"	gpu_calc_energy(dockpars_rotbondlist_length,\n"
"	                dockpars_num_of_atoms,\n"
"	                dockpars_true_ligand_atoms,\n"
"	                dockpars_gridsize_x,\n"
"	                dockpars_gridsize_y,\n"
"	                dockpars_gridsize_z,\n"
"	                                                     // g1 = gridsize_x\n"
"	                dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"	                dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"	                dockpars_fgrids,\n"
"	                dockpars_num_of_atypes,\n"
"	                dockpars_num_of_map_atypes,\n"
"	                dockpars_num_of_intraE_contributors,\n"
"	                dockpars_grid_spacing,\n"
"	                dockpars_coeff_elec,\n"
"	                dockpars_elec_min_distance,\n"
"	                dockpars_qasp,\n"
"	                dockpars_coeff_desolv,\n"
"	                dockpars_smooth,\n"
"	\n"
"	                genotype, /*WARNING: calculating the energy of the hardcoded genotype*/\n"
"	                &energy,\n"
"	                &run_id,\n"
"	                // Some OpenCL compilers don't allow declaring\n"
"	                // local variables within non-kernel functions.\n"
"	                // These local variables must be declared in a kernel,\n"
"	                // and then passed to non-kernel functions.\n"
"	                calc_coords,\n"
"	                partial_energies,\n"
"	                #if defined (DEBUG_ENERGY_KERNEL)\n"
"	                partial_interE,\n"
"	                partial_intraE,\n"
"	                #endif\n"
"#if 0\n"
"	                true,\n"
"#endif\n"
"	                kerconst_interintra,\n"
"	                kerconst_intracontrib,\n"
"	                kerconst_intra,\n"
"	                kerconst_rotlist,\n"
"	                kerconst_conform\n"
"	               );\n"
"	// =============================================================\n"
"\n"
"	// WARNING: hardcoded has priority over LGA genotype.\n"
"	// That means, if DEBUG_INITIAL_2BRT is defined, then\n"
"	// LGA genotype is not used (only for debugging purposes)\n"
"	if (tidx == 0)\n"
"	{\n"
"		printf(\"\\n\");\n"
"		printf(\"%20s \\n\", \"hardcoded genotype: \");\n"
"		printf(\"%20s %.6f\\n\", \"initial energy: \", energy);\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	#endif\n"
"\n"
"	// Calculating gradient\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// =============================================================\n"
"	gpu_calc_gradient(dockpars_rotbondlist_length,\n"
"	                  dockpars_num_of_atoms,\n"
"	                  dockpars_true_ligand_atoms,\n"
"	                  dockpars_gridsize_x,\n"
"	                  dockpars_gridsize_y,\n"
"	                  dockpars_gridsize_z,\n"
"	                                                       // g1 = gridsize_x\n"
"	                  dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"	                  dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"	                  dockpars_fgrids,\n"
"	                  dockpars_num_of_atypes,\n"
"	                  dockpars_num_of_map_atypes,\n"
"	                  dockpars_num_of_intraE_contributors,\n"
"	                  dockpars_grid_spacing,\n"
"	                  dockpars_coeff_elec,\n"
"	                  dockpars_elec_min_distance,\n"
"	                  dockpars_qasp,\n"
"	                  dockpars_coeff_desolv,\n"
"	                  dockpars_smooth,\n"
"	                  // Some OpenCL compilers don't allow declaring\n"
"	                  // local variables within non-kernel functions.\n"
"	                  // These local variables must be declared in a kernel,\n"
"	                  // and then passed to non-kernel functions.\n"
"	                  genotype,\n"
"	                  &energy,\n"
"	                  &run_id,\n"
"	                  calc_coords,\n"
"	                  kerconst_interintra,\n"
"	                  kerconst_intracontrib,\n"
"	                  kerconst_intra,\n"
"	                  kerconst_rotlist,\n"
"	                  kerconst_conform,\n"
"	                  rotbonds_const,\n"
"	                  rotbonds_atoms_const,\n"
"	                  num_rotating_atoms_per_rotbond_const,\n"
"	                  // Gradient-related arguments\n"
"	                  dockpars_num_of_genes,\n"
"	                  gradient_x, gradient_y, gradient_z,\n"
"	                  f_gradient_x, f_gradient_y, f_gradient_z,\n"
"	                  gradient\n"
"	                 );\n"
"	// =============================================================\n"
"\n"
"	// FIRE counters\n"
"	__local float velocity [ACTUAL_GENOTYPE_LENGTH]; // velocity\n"
"	__local float alpha;                             // alpha\n"
"	__local uint  count_success;                     // count_success\n"
"	__local float dt;                                // \"dt\"\n"
"\n"
"	// Calculating the gradient/velocity norm\n"
"	__local float gradient_tmp [ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float inv_gradient_norm;\n"
"	__local float velocity_tmp [ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float velocity_norm;\n"
"	__local float velnorm_div_gradnorm;\n"
"\n"
"	// Defining FIRE power\n"
"	__local float power_tmp [ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float power;\n"
"\n"
"	// Calculating gradient-norm components\n"
"	for ( int gene_counter = tidx;\n"
"	          gene_counter < dockpars_num_of_genes;\n"
"	          gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		gradient_tmp [gene_counter] = gradient [gene_counter] * gradient [gene_counter];\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	if (tidx == 0) {\n"
"		// nitializing\n"
"		alpha         = ALPHA_START;\n"
"		count_success = 0;\n"
"		dt            = DT_MAX_DIV_THREE;\n"
"\n"
"		// Initializing \"gradient norm\" to 0.0f,\n"
"		// but stored it in inv_gradient_norm\n"
"		inv_gradient_norm = 0.0f;\n"
"		\n"
"		// Summing up squares to continue calculation of \"gradient-norm\"\n"
"		for (int i = 0; i < dockpars_num_of_genes; i++) {\n"
"			inv_gradient_norm += gradient_tmp [i];\n"
"		}\n"
"		\n"
"		// Note: ALPHA_START is included as a factor here\n"
"		inv_gradient_norm = native_sqrt( inv_gradient_norm);\n"
"		inv_gradient_norm = ALPHA_START * native_recip(inv_gradient_norm);\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// Starting velocity\n"
"	// This equation was found by trial and error\n"
"	for ( int gene_counter = tidx;\n"
"	          gene_counter < dockpars_num_of_genes;\n"
"	          gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		velocity [gene_counter] = - gradient [gene_counter] * inv_gradient_norm;\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// Keeping track of best genotype which \n"
"	// may or may not be the last genotype\n"
"	if (tidx == 0) {\n"
"		best_energy = energy;\n"
"		for (int i = 0; i < dockpars_num_of_genes; i++) {\n"
"			best_genotype [i] = genotype [i];\n"
"		}\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// Perform fire iterations\n"
"\n"
"	// The termination criteria is based on \n"
"	// a maximum number of iterations, and\n"
"	// value of \"dt\" (fire specific)\n"
"	do {\n"
"		// Printing number of FIRE iterations\n"
"		#if defined (DEBUG_FIRE_MINIMIZER)\n"
"		if (tidx == 0) {\n"
"			printf(\"%s\\n\", \"----------------------------------------------------------\");\n"
"		}\n"
"		#endif\n"
"		\n"
"		#if defined (DEBUG_FIRE_MINIMIZER) || defined (PRINT_FIRE_MINIMIZER_ENERGY_EVOLUTION)\n"
"		if (tidx == 0) {\n"
"			printf(\"%-15s %-3u \", \"# FIRE iteration: \", iteration_cnt);\n"
"		}\n"
"		#endif\n"
"\n"
"		// Creating new (candidate) genotypes\n"
"		for ( int gene_counter = tidx;\n"
"		          gene_counter < dockpars_num_of_genes;\n"
"		          gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			candidate_genotype [gene_counter] = genotype [gene_counter] + dt * velocity [gene_counter];\n"
"		}\n"
"\n"
"// Replacing separate gradient and energy \n"
"// calculations with a single & unified\n"
"// gpu_calc_energrad() function\n"
"// IMPORTANT: be careful with input/output (RE) assignment\n"
"// of genotypes, energy, and gradients\n"
"#if 0\n"
"		// =============================================================\n"
"		// Calculating (candidate) gradient\n"
"		// from \"candidate_genotype\"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		gpu_calc_gradient(dockpars_rotbondlist_length,\n"
"		                  dockpars_num_of_atoms,\n"
"		                  dockpars_true_ligand_atoms,\n"
"		                  dockpars_gridsize_x,\n"
"		                  dockpars_gridsize_y,\n"
"		                  dockpars_gridsize_z,\n"
"		                                                       // g1 = gridsize_x\n"
"		                  dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"		                  dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"		                  dockpars_fgrids,\n"
"		                  dockpars_num_of_atypes,\n"
"		                  dockpars_num_of_map_atypes,\n"
"		                  dockpars_num_of_intraE_contributors,\n"
"		                  dockpars_grid_spacing,\n"
"		                  dockpars_coeff_elec,\n"
"		                  dockpars_elec_min_distance,\n"
"		                  dockpars_qasp,\n"
"		                  dockpars_coeff_desolv,\n"
"		                  dockpars_smooth,\n"
"		                  // Some OpenCL compilers don't allow declaring\n"
"		                  // local variables within non-kernel functions.\n"
"		                  // These local variables must be declared in a kernel,\n"
"		                  // and then passed to non-kernel functions.\n"
"		                  candidate_genotype,\n"
"		                  &candidate_energy,\n"
"		                  &run_id,\n"
"		                  calc_coords,\n"
"		                  kerconst_interintra,\n"
"		                  kerconst_intracontrib,\n"
"		                  kerconst_intra,\n"
"		                  kerconst_rotlist,\n"
"		                  kerconst_conform,\n"
"		                  rotbonds_const,\n"
"		                  rotbonds_atoms_const,\n"
"		                  num_rotating_atoms_per_rotbond_const,\n"
"		                  // Gradient-related arguments\n"
"		                  dockpars_num_of_genes,\n"
"		                  gradient_x, gradient_y, gradient_z,\n"
"		                  f_gradient_x, f_gradient_y, f_gradient_z,\n"
"		                  candidate_gradient\n"
"		                 );\n"
"		// =============================================================\n"
"\n"
"		// Evaluating (candidate) genotype\n"
"		// i.e. get (candidate) energy\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// =============================================================\n"
"		gpu_calc_energy(dockpars_rotbondlist_length,\n"
"		                dockpars_num_of_atoms,\n"
"		                dockpars_true_ligand_atoms,\n"
"		                dockpars_gridsize_x,\n"
"		                dockpars_gridsize_y,\n"
"		                dockpars_gridsize_z,\n"
"		                                                     // g1 = gridsize_x\n"
"		                dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"		                dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"		                dockpars_fgrids,\n"
"		                dockpars_num_of_atypes,\n"
"		                dockpars_num_of_map_atypes,\n"
"		                dockpars_num_of_intraE_contributors,\n"
"		                dockpars_grid_spacing,\n"
"		                dockpars_coeff_elec,\n"
"		                dockpars_elec_min_distance,\n"
"		                dockpars_qasp,\n"
"		                dockpars_coeff_desolv,\n"
"		                dockpars_smooth,\n"
"		\n"
"		                candidate_genotype, /*WARNING: calculating the energy of the hardcoded genotype*/\n"
"		                &candidate_energy,\n"
"		                &run_id,\n"
"		                // Some OpenCL compilers don't allow declaring\n"
"		                // local variables within non-kernel functions.\n"
"		                // These local variables must be declared in a kernel,\n"
"		                // and then passed to non-kernel functions.\n"
"		                calc_coords,\n"
"		                partial_energies,\n"
"		                #if defined (DEBUG_ENERGY_KERNEL)\n"
"		                partial_interE,\n"
"		                partial_intraE,\n"
"		                #endif\n"
"#if 0\n"
"		                true,\n"
"#endif\n"
"		                kerconst_interintra,\n"
"		                kerconst_intracontrib,\n"
"		                kerconst_intra,\n"
"		                kerconst_rotlist,\n"
"		                kerconst_conform\n"
"		               );\n"
"		// =============================================================\n"
"#endif\n"
"\n"
"		// =============================================================\n"
"		// =============================================================\n"
"		// =============================================================\n"
"		// Calculating energy & gradient\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		gpu_calc_energrad(dockpars_rotbondlist_length,\n"
"		                  dockpars_num_of_atoms,\n"
"		                  dockpars_true_ligand_atoms,\n"
"		                  dockpars_gridsize_x,\n"
"		                  dockpars_gridsize_y,\n"
"		                  dockpars_gridsize_z,\n"
"		                  // g1 = gridsize_x\n"
"		                  dockpars_gridsize_x_times_y, 		// g2 = gridsize_x * gridsize_y\n"
"		                  dockpars_gridsize_x_times_y_times_z,	// g3 = gridsize_x * gridsize_y * gridsize_z\n"
"		                  dockpars_fgrids,\n"
"		                  dockpars_num_of_atypes,\n"
"		                  dockpars_num_of_map_atypes,\n"
"		                  dockpars_num_of_intraE_contributors,\n"
"		                  dockpars_grid_spacing,\n"
"		                  dockpars_coeff_elec,\n"
"		                  dockpars_elec_min_distance,\n"
"		                  dockpars_qasp,\n"
"		                  dockpars_coeff_desolv,\n"
"		                  dockpars_smooth,\n"
"		                  // Some OpenCL compilers don't allow declaring\n"
"		                  // local variables within non-kernel functions.\n"
"		                  // These local variables must be declared in a kernel,\n"
"		                  // and then passed to non-kernel functions.\n"
"		                  candidate_genotype,\n"
"		                  &candidate_energy,\n"
"		                  &run_id,\n"
"		                  calc_coords,\n"
"		                  partial_energies,\n"
"		                  #if defined (DEBUG_ENERGY_KERNEL)\n"
"		                  partial_interE,\n"
"		                  partial_intraE,\n"
"		                  #endif\n"
"		                  kerconst_interintra,\n"
"		                  kerconst_intracontrib,\n"
"		                  kerconst_intra,\n"
"		                  kerconst_rotlist,\n"
"		                  kerconst_conform,\n"
"		                  rotbonds_const,\n"
"		                  rotbonds_atoms_const,\n"
"		                  num_rotating_atoms_per_rotbond_const,\n"
"		                  // Gradient-related arguments\n"
"		                  dockpars_num_of_genes,\n"
"		                  gradient_x, gradient_y, gradient_z,\n"
"		                  f_gradient_x, f_gradient_y, f_gradient_z,\n"
"		                  candidate_gradient\n"
"		                 );\n"
"		// =============================================================\n"
"		// =============================================================\n"
"		// =============================================================\n"
"\n"
"		// Calculating power\n"
"		// power is force * velocity.\n"
"		// force = -gradient\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		for ( int gene_counter = tidx;\n"
"		          gene_counter < dockpars_num_of_genes;\n"
"		          gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			// Calculating power\n"
"			power_tmp [gene_counter] = -candidate_gradient [gene_counter] * velocity [gene_counter];\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (tidx == 0) {\n"
"			power = 0.0f;\n"
"			// Summing dot products\n"
"			for (int i = 0; i < dockpars_num_of_genes; i++) {\n"
"				power += power_tmp [i];\n"
"			}\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		#if defined (DEBUG_ENERGY_FIRE)\n"
"		if (/*(get_group_id(0) == 0) &&*/ (tidx == 0)) {\n"
"			#if defined (PRINT_FIRE_ENERGIES)\n"
"			printf(\"\\n\");\n"
"			printf(\"%-10s %-10.6f \\n\", \"intra: \",  partial_intraE[0]);\n"
"			printf(\"%-10s %-10.6f \\n\", \"grids: \",  partial_interE[0]);\n"
"			printf(\"%-10s %-10.6f \\n\", \"Energy: \", (partial_intraE[0] + partial_interE[0]));\n"
"			#endif\n"
"\n"
"			printf(\"\\n\");\n"
"			printf(\"%-15s %-10.6f \\n\", \"energy: \"     ,  energy);\n"
"			printf(\"%-15s %-10.6f \\n\", \"best_energy: \",  best_energy);\n"
"\n"
"			printf(\"\\n%-15s %-10.6f \\n\",\"dt: \"           ,  dt);\n"
"			printf(\"%-15s %-10.6f \\n\",  \"power: \"        ,  power);\n"
"			printf(\"%-15s %-10.6f \\n\",  \"alpha: \"        ,  alpha);\n"
"			printf(\"%-15s %-10u \\n\\n\",   \"count_success: \" ,  count_success);\n"
"\n"
"			#if defined (PRINT_FIRE_GENES_AND_GRADS)\n"
"			for(int i = 0; i < dockpars_num_of_genes; i++) {\n"
"				if (i == 0) {\n"
"					//printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"					printf(\"%13s %13s %5s %15s %21s %15s\\n\", \"gene_id\", \"genotype\", \"|\", \"gradient\", \"(autodockdevpy units)\", \"velocity\");\n"
"				}\n"
"				printf(\"%13u %13.6f %5s %15.6f %21.6f %15.6f\\n\", i, genotype[i], \"|\", gradient[i], (i<3)? (gradient[i]/dockpars_grid_spacing):(gradient[i]*180.0f/PI_FLOAT), velocity[i]);\n"
"			}\n"
"\n"
"			for(int i = 0; i < dockpars_num_of_genes; i++) {\n"
"				if (i == 0) {\n"
"					//printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"					printf(\"\\n\");\n"
"					printf(\"%13s %13s %5s %15s\\n\", \"gene_id\", \"cand_genotype\", \"|\", \"cand_gradient\");\n"
"				}\n"
"				printf(\"%13u %13.6f %5s %15.6f\\n\", i, candidate_genotype[i], \"|\", candidate_gradient[i]);\n"
"			}\n"
"			#endif\n"
"\n"
"			#if defined (PRINT_FIRE_ATOMIC_COORDS)\n"
"			for(int i = 0; i < dockpars_num_of_atoms; i++) {\n"
"				if (i == 0) {\n"
"					printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"					printf(\"%s\\n\", \"Coordinates calculated by calcenergy.cl\");\n"
"					printf(\"%12s %12s %12s %12s\\n\", \"atom_id\", \"coords.x\", \"coords.y\", \"coords.z\");\n"
"				}\n"
"				printf(\"%12u %12.6f %12.6f %12.6f\\n\", i, calc_coords_x[i], calc_coords_y[i], calc_coords_z[i]);\n"
"			}\n"
"			printf(\"\\n\");\n"
"			#endif\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		#endif\n"
"\n"
"		// Going uphill (against the gradient)\n"
"		if (power < 0.0f) {\n"
"			// Using same equation as for starting velocity\n"
"			for ( int gene_counter = tidx;\n"
"			          gene_counter < dockpars_num_of_genes;\n"
"			          gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"			{\n"
"				// Calculating gradient-norm\n"
"				gradient_tmp [gene_counter] = gradient [gene_counter] * gradient [gene_counter];\n"
"			}\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			if (tidx == 0) {\n"
"				inv_gradient_norm = 0.0f;\n"
"\n"
"				// Summing dot products\n"
"				for (int i = 0; i < dockpars_num_of_genes; i++) {\n"
"					inv_gradient_norm += gradient_tmp [i];\n"
"				}\n"
"\n"
"				// Note: ALPHA is included as a factor here\n"
"				inv_gradient_norm = native_sqrt(inv_gradient_norm);\n"
"				inv_gradient_norm = ALPHA_START * native_recip(inv_gradient_norm);\n"
"			}\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			for ( int gene_counter = tidx;\n"
"			          gene_counter < dockpars_num_of_genes;\n"
"			          gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"			{\n"
"				velocity [gene_counter] = - gradient [gene_counter] * inv_gradient_norm;\n"
"			}\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		 	if (tidx == 0) {\n"
"				count_success = 0;\n"
"				alpha         = ALPHA_START;\n"
"				dt            = dt * DT_DEC;\n"
"\n"
"				#if defined PRINT_FIRE_PARAMETERS\n"
"				printf(\"\\nPower is negative :( = %f\\n\", power);\n"
"				printf(\"\\n %15s %10.7f\\n %15s %10.7f\\n\", \"alpha: \", alpha,  \"dt: \", dt);\n"
"				#endif\n"
"			}\n"
"		}\n"
"		// Going downhill\n"
"		else {\n"
"			if (tidx == 0) {\n"
"				count_success ++;\n"
"\n"
"				#if defined PRINT_FIRE_PARAMETERS\n"
"				printf(\"\\nPower is positive :) = %f\\n\", power);\n"
"				printf(\"\\n %15s %10.7f\\n %15s %10.7f\\n\", \"old alpha: \", alpha, \"old dt: \", dt);\n"
"				#endif\n"
"\n"
"				// Reaching minimum number of consecutive successful steps (power >= 0)\n"
"				if (count_success > SUCCESS_MIN) {\n"
"					dt    = fmin (dt * DT_INC, DT_MAX);	// increase dt\n"
"					alpha = alpha * ALPHA_DEC; 		// decrease alpha\n"
"\n"
"					#if defined PRINT_FIRE_PARAMETERS\n"
"					printf(\"\\n count_success > %u\\n\", SUCCESS_MIN);\n"
"					printf(\"\\n %10s %7.7f\\n %10s %7.7f\\n\", \"new alpha: \", alpha, \"new dt: \", dt);\n"
"					#endif\n"
"				}\n"
"				else {\n"
"					#if defined PRINT_FIRE_PARAMETERS\n"
"					printf(\"\\n count_success <= %u, do NOT update alpha or dt\\n\", SUCCESS_MIN);\n"
"					#endif\n"
"				}\n"
"			}\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// --------------------------------------\n"
"		// Always update: energy, genotype, gradient\n"
"		for ( int gene_counter = tidx;\n"
"		          gene_counter < dockpars_num_of_genes;\n"
"		          gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			if (gene_counter == 0) {\n"
"				energy = candidate_energy;\n"
"			}\n"
"			genotype [gene_counter] = candidate_genotype [gene_counter];\n"
"			gradient [gene_counter] = candidate_gradient [gene_counter];\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// --------------------------------------\n"
"		// Calculating gradient-norm\n"
"		for ( int gene_counter = tidx;\n"
"		          gene_counter < dockpars_num_of_genes;\n"
"		          gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			gradient_tmp [gene_counter] = gradient [gene_counter] * gradient [gene_counter];\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (tidx == 0) {\n"
"			inv_gradient_norm = 0.0f;\n"
"\n"
"			// Summing dot products\n"
"			for (int i = 0; i < dockpars_num_of_genes; i++) {\n"
"				inv_gradient_norm += gradient_tmp [i];\n"
"			}\n"
"\n"
"			inv_gradient_norm = native_sqrt(inv_gradient_norm);\n"
"			inv_gradient_norm = native_recip(inv_gradient_norm);\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// --------------------------------------\n"
"		// Calculating velocity-norm\n"
"		for ( int gene_counter = tidx;\n"
"		          gene_counter < dockpars_num_of_genes;\n"
"		          gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			velocity_tmp [gene_counter] = velocity [gene_counter] * velocity [gene_counter];\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (tidx == 0) {\n"
"			velocity_norm  = 0.0f;\n"
"\n"
"			// Summing dot products\n"
"			for (int i = 0; i < dockpars_num_of_genes; i++) {\n"
"				velocity_norm += velocity_tmp [i];\n"
"			}\n"
"\n"
"			// Note: alpha is included as a factor here\n"
"			velocity_norm = native_sqrt(velocity_norm);\n"
"			velnorm_div_gradnorm = alpha * velocity_norm * inv_gradient_norm;\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// --------------------------------------\n"
"		// Calculating velocity\n"
"		for ( int gene_counter = tidx;\n"
"		          gene_counter < dockpars_num_of_genes;\n"
"		          gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			// NOTE: \"velnorm_div_gradnorm\" includes already the \"alpha\" factor\n"
"			velocity [gene_counter] = (1 - alpha) * velocity [gene_counter] - gradient [gene_counter] * velnorm_div_gradnorm;\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// --------------------------------------\n"
"		// Updating number of fire iterations (energy evaluations)\n"
"		if (tidx == 0) {\n"
"	    		iteration_cnt = iteration_cnt + 1;\n"
"\n"
"			#if defined (DEBUG_FIRE_MINIMIZER) || defined (PRINT_FIRE_MINIMIZER_ENERGY_EVOLUTION)\n"
"			printf(\"%20s %10.6f\\n\", \"new.energy: \", energy);\n"
"			#endif\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL6)\n"
"			printf(\"%-18s [%-5s]---{%-5s}   [%-10.7f]---{%-10.7f}\\n\", \"-ENERGY-KERNEL6-\", \"GRIDS\", \"INTRA\", partial_interE[0], partial_intraE[0]);\n"
"			#endif\n"
"\n"
"			if (energy <  best_energy) {\n"
"				best_energy = energy;\n"
"\n"
"				for(int i = 0; i < dockpars_num_of_genes; i++) { \n"
"					best_genotype[i] = genotype[i];\n"
"				}\n"
"			}\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	} while ((iteration_cnt < dockpars_max_num_of_iters) && (dt > DT_MIN));\n"
"  	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"\n"
"  	// Updating eval counter and energy\n"
"	if (tidx == 0) {\n"
"		dockpars_evals_of_new_entities[run_id*dockpars_pop_size+entity_id] += iteration_cnt;\n"
"		dockpars_energies_next[run_id*dockpars_pop_size+entity_id] = best_energy;\n"
"\n"
"		#if defined (DEBUG_FIRE_MINIMIZER) || defined (PRINT_FIRE_MINIMIZER_ENERGY_EVOLUTION)\n"
"		printf(\"\\n\");\n"
"		printf(\"Termination criteria: ( dt >= %10.10f ) OR ( #fire-iters >= %-3u )\\n\", DT_MIN, dockpars_max_num_of_iters);\n"
"		printf(\"-------> End of FIRE minimization cycle, num of energy evals: %u, final energy: %.6f\\n\", iteration_cnt, best_energy);\n"
"		#endif\n"
"	}\n"
"\n"
"	// Mapping torsion angles\n"
"	for ( int gene_counter = tidx;\n"
"	          gene_counter < dockpars_num_of_genes;\n"
"	          gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		if (gene_counter >= 3) {\n"
"			map_angle(&(best_genotype[gene_counter]));\n"
"		}\n"
"	}\n"
"\n"
"	// Updating old offspring in population\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	event_t ev2 = async_work_group_copy(dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"	                                    best_genotype,\n"
"	                                    dockpars_num_of_genes, 0);\n"
"\n"
"	// Asynchronous copy should be finished by here\n"
"	wait_group_events(1, &ev2);\n"
"}\n"
"/*\n"
"\n"
"AutoDock-GPU, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"For some of the code, Copyright (C) 2019 Computational Structural Biology Center, the Scripps Research Institute.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This library is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU Lesser General Public\n"
"License as published by the Free Software Foundation; either\n"
"version 2.1 of the License, or (at your option) any later version.\n"
"\n"
"This library is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"Lesser General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU Lesser General Public\n"
"License along with this library; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n"
"\n"
"*/\n"
"\n"
"\n"
"#define ADADELTA_AUTOSTOP // Stopping criterion from Solis-Wets\n"
"\n"
"// Gradient-based adadelta minimizer\n"
"// https://arxiv.org/pdf/1212.5701.pdf\n"
"// Alternative to Solis-Wets / Steepest-Descent / FIRE\n"
"\n"
"// \"rho\": controls degree of memory of previous gradients\n"
"//        ranges between [0, 1[\n"
"//        \"rho\" = 0.9 most popular value\n"
"// \"epsilon\":  to better condition the square root\n"
"\n"
"// Adadelta parameters (TODO: to be moved to header file?)\n"
"//#define RHO             0.9f\n"
"//#define EPSILON         1e-6f\n"
"#define RHO             0.8f\n"
"#define EPSILON         1e-2f\n"
"\n"
"// Enabling \"DEBUG_ENERGY_ADADELTA\" requires\n"
"// manually enabling \"DEBUG_ENERGY_KERNEL\" in calcenergy.cl\n"
"//#define DEBUG_ENERGY_ADADELTA\n"
"//#define PRINT_ADADELTA_ENERGIES\n"
"//#define PRINT_ADADELTA_GENES_AND_GRADS\n"
"//#define PRINT_ADADELTA_ATOMIC_COORDS\n"
"//#define DEBUG_SQDELTA_ADADELTA\n"
"\n"
"// Enable DEBUG_ADADELTA_MINIMIZER for a seeing a detailed ADADELTA evolution\n"
"// If only PRINT_ADADELTA_MINIMIZER_ENERGY_EVOLUTION is enabled,\n"
"// then a only a simplified ADADELTA evolution will be shown\n"
"//#define DEBUG_ADADELTA_MINIMIZER\n"
"//#define PRINT_ADADELTA_MINIMIZER_ENERGY_EVOLUTION\n"
"\n"
"// Enable this for debugging ADADELTA from a defined initial genotype\n"
"//#define DEBUG_ADADELTA_INITIAL_2BRT\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gradient_minAD(\n"
"                     int    dockpars_num_of_atoms,\n"
"                     int    dockpars_true_ligand_atoms,\n"
"                     int    dockpars_num_of_atypes,\n"
"                     int    dockpars_num_of_map_atypes,\n"
"                     int    dockpars_num_of_intraE_contributors,\n"
"                     int    dockpars_gridsize_x,\n"
"                     int    dockpars_gridsize_y,\n"
"                     int    dockpars_gridsize_z,\n"
"                                                                 // g1 = gridsize_x\n"
"                     uint   dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"                     uint   dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"                     float  dockpars_grid_spacing,\n"
"      __global const float* restrict dockpars_fgrids, // This is too large to be allocated in __constant\n"
"                     int    dockpars_rotbondlist_length,\n"
"                     float  dockpars_coeff_elec,\n"
"                     float  dockpars_elec_min_distance,\n"
"                     float  dockpars_coeff_desolv,\n"
"      __global       float* restrict dockpars_conformations_next,\n"
"      __global       float* restrict dockpars_energies_next,\n"
"      __global       int*   restrict dockpars_evals_of_new_entities,\n"
"      __global       uint*  restrict dockpars_prng_states,\n"
"                     int    dockpars_pop_size,\n"
"                     int    dockpars_num_of_genes,\n"
"                     float  dockpars_lsearch_rate,\n"
"                     uint   dockpars_num_of_lsentities,\n"
"                     uint   dockpars_max_num_of_iters,\n"
"                     float  dockpars_qasp,\n"
"                     float  dockpars_smooth,\n"
"\n"
"    __constant       kernelconstant_interintra*   kerconst_interintra,\n"
"      __global const kernelconstant_intracontrib* kerconst_intracontrib,\n"
"    __constant       kernelconstant_intra*        kerconst_intra,\n"
"    __constant       kernelconstant_rotlist*      kerconst_rotlist,\n"
"    __constant       kernelconstant_conform*      kerconst_conform,\n"
"\n"
"    __constant       int*   rotbonds_const,\n"
"      __global const int*   rotbonds_atoms_const,\n"
"    __constant       int*   num_rotating_atoms_per_rotbond_const\n"
"              )\n"
"// The GPU global function performs gradient-based minimization on (some) entities of conformations_next.\n"
"// The number of OpenCL compute units (CU) which should be started equals to num_of_minEntities*num_of_runs.\n"
"// This way the first num_of_lsentities entity of each population will be subjected to local search\n"
"// (and each CU carries out the algorithm for one entity).\n"
"// Since the first entity is always the best one in the current population,\n"
"// it is always tested according to the ls probability, and if it not to be\n"
"// subjected to local search, the entity with ID num_of_lsentities is selected instead of the first one (with ID 0).\n"
"{\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"	int tidx = get_local_id(0);\n"
"\n"
"	// Determining entity, and its run, energy, and genotype\n"
"	__local int   entity_id;\n"
"	__local int   run_id;\n"
"	__local float energy;\n"
"	__local float genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	// Iteration counter for the minimizer\n"
"	__local uint iteration_cnt;\n"
"\n"
"	if (tidx == 0)\n"
"	{\n"
"		run_id = get_group_id(0) / dockpars_num_of_lsentities;\n"
"		entity_id = get_group_id(0) - run_id * dockpars_num_of_lsentities; // modulus in different form\n"
"\n"
"		// Since entity 0 is the best one due to elitism,\n"
"		// it should be subjected to random selection\n"
"		if (entity_id == 0) {\n"
"			// If entity 0 is not selected according to LS-rate,\n"
"			// choosing another entity\n"
"			if (100.0f*gpu_randf(dockpars_prng_states) > dockpars_lsearch_rate) {\n"
"				entity_id = dockpars_num_of_lsentities; // AT - Should this be (uint)(dockpars_pop_size * gpu_randf(dockpars_prng_states))?\n"
"			}\n"
"		}\n"
"		\n"
"		energy = dockpars_energies_next[run_id*dockpars_pop_size+entity_id];\n"
"\n"
"		// Initializing gradient-minimizer counters and flags\n"
"		iteration_cnt  = 0;\n"
"\n"
"		#if defined (DEBUG_ADADELTA_MINIMIZER) || defined (PRINT_ADADELTA_MINIMIZER_ENERGY_EVOLUTION)\n"
"		printf(\"\\n\");\n"
"		printf(\"-------> Start of ADADELTA minimization cycle\\n\");\n"
"		printf(\"%20s %6u\\n\", \"run_id: \", run_id);\n"
"		printf(\"%20s %6u\\n\", \"entity_id: \", entity_id);\n"
"		printf(\"\\n\");\n"
"		printf(\"%20s \\n\", \"LGA genotype: \");\n"
"		printf(\"%20s %.6f\\n\", \"initial energy: \", energy);\n"
"		#endif\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	event_t ev = async_work_group_copy(genotype,\n"
"	                                   dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"	                                   dockpars_num_of_genes, 0);\n"
"\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"\n"
"	// Partial results of the gradient step\n"
"	__local float gradient[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	// Energy may go up, so we keep track of the best energy ever calculated.\n"
"	// Then, we return the genotype corresponding \n"
"	// to the best observed energy, i.e. \"best_genotype\"\n"
"	__local float best_energy;\n"
"	__local float best_genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	// -------------------------------------------------------------------\n"
"	// Calculate gradients (forces) for intermolecular energy\n"
"	// Derived from autodockdev/maps.py\n"
"	// -------------------------------------------------------------------\n"
"	// Gradient of the intermolecular energy per each ligand atom\n"
"	// Also used to store the accummulated gradient per each ligand atom\n"
"#ifdef FLOAT_GRADIENTS\n"
"	__local float gradient_x[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_y[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_z[MAX_NUM_OF_ATOMS];\n"
"#else\n"
"	__local int   gradient_x[MAX_NUM_OF_ATOMS];\n"
"	__local int   gradient_y[MAX_NUM_OF_ATOMS];\n"
"	__local int   gradient_z[MAX_NUM_OF_ATOMS];\n"
"#endif\n"
"	__local float accumulator_x[NUM_OF_THREADS_PER_BLOCK];\n"
"	__local float accumulator_y[NUM_OF_THREADS_PER_BLOCK];\n"
"	__local float accumulator_z[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	// Ligand-atom position and partial energies\n"
"	__local float4 calc_coords[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	#if defined (DEBUG_ENERGY_KERNEL)\n"
"	__local float partial_interE[NUM_OF_THREADS_PER_BLOCK];\n"
"	__local float partial_intraE[NUM_OF_THREADS_PER_BLOCK];\n"
"	#endif\n"
"\n"
"	// Vector for storing squared gradients E[g^2]\n"
"	__local float square_gradient[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	// Update vector, i.e., \"delta\".\n"
"	// It is added to the genotype to create the next genotype.\n"
"	// E.g. in steepest descent \"delta\" is -1.0 * stepsize * gradient\n"
"	__local float delta[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	// Squared updates E[dx^2]\n"
"	__local float square_delta[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	// Asynchronous copy should be finished by here\n"
"	wait_group_events(1, &ev);\n"
"\n"
"	// Enable this for debugging ADADELTA from a defined initial genotype\n"
"#if defined (DEBUG_ADADELTA_INITIAL_2BRT)\n"
"	if (tidx == 0) {\n"
"		// 2brt\n"
"		genotype[0]  = 24.093334f;\n"
"		genotype[1]  = 24.658667f;\n"
"		genotype[2]  = 24.210667f;\n"
"		genotype[3]  = 50.0f;\n"
"		genotype[4]  = 50.0f;\n"
"		genotype[5]  = 50.0f;\n"
"		genotype[6]  = 0.0f;\n"
"		genotype[7]  = 0.0f;\n"
"		genotype[8]  = 0.0f;\n"
"		genotype[9]  = 0.0f;\n"
"		genotype[10] = 0.0f;\n"
"		genotype[11] = 0.0f;\n"
"		genotype[12] = 0.0f;\n"
"		genotype[13] = 0.0f;\n"
"		genotype[14] = 0.0f;\n"
"		genotype[15] = 0.0f;\n"
"		genotype[16] = 0.0f;\n"
"		genotype[17] = 0.0f;\n"
"		genotype[18] = 0.0f;\n"
"		genotype[19] = 0.0f;\n"
"		genotype[20] = 0.0f;\n"
"	}\n"
"	// Evaluating candidate\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// =============================================================\n"
"	gpu_calc_energy(dockpars_rotbondlist_length,\n"
"	                dockpars_num_of_atoms,\n"
"	                dockpars_true_ligand_atoms,\n"
"	                dockpars_gridsize_x,\n"
"	                dockpars_gridsize_y,\n"
"	                dockpars_gridsize_z,\n"
"	                                                     // g1 = gridsize_x\n"
"	                dockpars_gridsize_x_times_y,         // g2 = gridsize_x * gridsize_y\n"
"	                dockpars_gridsize_x_times_y_times_z, // g3 = gridsize_x * gridsize_y * gridsize_z\n"
"	                dockpars_fgrids,\n"
"	                dockpars_num_of_atypes,\n"
"	                dockpars_num_of_map_atypes,\n"
"	                dockpars_num_of_intraE_contributors,\n"
"	                dockpars_grid_spacing,\n"
"	                dockpars_coeff_elec,\n"
"	                dockpars_elec_min_distance,\n"
"	                dockpars_qasp,\n"
"	                dockpars_coeff_desolv,\n"
"	                dockpars_smooth,\n"
"	\n"
"	                genotype, /*WARNING: calculating the energy of the hardcoded genotype*/\n"
"	                &energy,\n"
"	                &run_id,\n"
"	                // Some OpenCL compilers don't allow declaring\n"
"	                // local variables within non-kernel functions.\n"
"	                // These local variables must be declared in a kernel,\n"
"	                // and then passed to non-kernel functions.\n"
"	                calc_coords,\n"
"	                partial_energies,\n"
"	                #if defined (DEBUG_ENERGY_KERNEL)\n"
"	                partial_interE,\n"
"	                partial_intraE,\n"
"	                #endif\n"
"#if 0\n"
"	                true,\n"
"#endif\n"
"	                kerconst_interintra,\n"
"	                kerconst_intracontrib,\n"
"	                kerconst_intra,\n"
"	                kerconst_rotlist,\n"
"	                kerconst_conform\n"
"	               );\n"
"	// =============================================================\n"
"\n"
"	// WARNING: hardcoded has priority over LGA genotype.\n"
"	// That means, if DEBUG_INITIAL_2BRT is defined, then\n"
"	// LGA genotype is not used (only for debugging purposes)\n"
"	if (tidx == 0)\n"
"	{\n"
"		printf(\"\\n\");\n"
"		printf(\"%20s \\n\", \"hardcoded genotype: \");\n"
"		printf(\"%20s %.6f\\n\", \"initial energy: \", energy);\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif // DEBUG_ADADELTA_INITIAL_2BRT\n"
"\n"
"	// Initializing vectors\n"
"	for( int i = tidx;\n"
"	         i < dockpars_num_of_genes;\n"
"	         i+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		gradient[i]        = 0.0f;\n"
"		square_gradient[i] = 0.0f;\n"
"		delta[i]           = 0.0f;\n"
"		square_delta[i]    = 0.0f;\n"
"		best_genotype[i]   = genotype[i];\n"
"	}\n"
"\n"
"	// Initializing best energy\n"
"	if (tidx == 0) {\n"
"		best_energy = INFINITY;\n"
"	}\n"
"\n"
"#ifdef ADADELTA_AUTOSTOP\n"
"	__local float varrho;\n"
"	__local int   cons_succ;\n"
"	__local int   cons_fail;\n"
"	if (tidx == 0) {\n"
"		varrho = 1.0f;\n"
"		cons_succ = 0;\n"
"		cons_fail = 0;\n"
"	}\n"
"#endif\n"
"	// Perform adadelta iterations\n"
"\n"
"	// The termination criteria is based on\n"
"	// a maximum number of iterations, and\n"
"	// the minimum step size allowed for single-floating point numbers\n"
"	// (IEEE-754 single float has a precision of about 6 decimal digits)\n"
"	do {\n"
"		// Printing number of ADADELTA iterations\n"
"		#if defined (DEBUG_ADADELTA_MINIMIZER) || defined (PRINT_ADADELTA_MINIMIZER_ENERGY_EVOLUTION)\n"
"		if (tidx == 0) {\n"
"			#if defined (DEBUG_ADADELTA_MINIMIZER)\n"
"			printf(\"%s\\n\", \"----------------------------------------------------------\");\n"
"			#endif\n"
"			printf(\"%-15s %-3u \", \"# ADADELTA iteration: \", iteration_cnt);\n"
"		}\n"
"		#endif\n"
"\n"
"		// =============================================================\n"
"		// =============================================================\n"
"		// =============================================================\n"
"		// Calculating energy & gradient\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		gpu_calc_energrad(\n"
"		                  dockpars_rotbondlist_length,\n"
"		                  dockpars_num_of_atoms,\n"
"		                  dockpars_true_ligand_atoms,\n"
"		                  dockpars_gridsize_x,\n"
"		                  dockpars_gridsize_y,\n"
"		                  dockpars_gridsize_z,\n"
"		                  // g1 = gridsize_x\n"
"		                  dockpars_gridsize_x_times_y, 		// g2 = gridsize_x * gridsize_y\n"
"		                  dockpars_gridsize_x_times_y_times_z,	// g3 = gridsize_x * gridsize_y * gridsize_z\n"
"		                  dockpars_fgrids,\n"
"		                  dockpars_num_of_atypes,\n"
"		                  dockpars_num_of_map_atypes,\n"
"		                  dockpars_num_of_intraE_contributors,\n"
"		                  dockpars_grid_spacing,\n"
"		                  dockpars_coeff_elec,\n"
"		                  dockpars_elec_min_distance,\n"
"		                  dockpars_qasp,\n"
"		                  dockpars_coeff_desolv,\n"
"		                  dockpars_smooth,\n"
"		                  // Some OpenCL compilers don't allow declaring\n"
"		                  // local variables within non-kernel functions.\n"
"		                  // These local variables must be declared in a kernel,\n"
"		                  // and then passed to non-kernel functions.\n"
"		                  genotype,\n"
"		                  &energy,\n"
"		                  &run_id,\n"
"		                  calc_coords,\n"
"		                  partial_energies,\n"
"		                  #if defined (DEBUG_ENERGY_KERNEL)\n"
"		                  partial_interE,\n"
"		                  partial_intraE,\n"
"		                  #endif\n"
"		                  kerconst_interintra,\n"
"		                  kerconst_intracontrib,\n"
"		                  kerconst_intra,\n"
"		                  kerconst_rotlist,\n"
"		                  kerconst_conform,\n"
"		                  rotbonds_const,\n"
"		                  rotbonds_atoms_const,\n"
"		                  num_rotating_atoms_per_rotbond_const,\n"
"		                  // Gradient-related arguments\n"
"		                  dockpars_num_of_genes,\n"
"		                  gradient_x, gradient_y, gradient_z,\n"
"		                  accumulator_x, accumulator_y, accumulator_z,\n"
"		                  gradient\n"
"		                 );\n"
"		// =============================================================\n"
"		// =============================================================\n"
"		// =============================================================\n"
"		#if defined (DEBUG_ENERGY_ADADELTA)\n"
"		if (tidx == 0) {\n"
"			#if defined (PRINT_ADADELTA_ENERGIES)\n"
"			printf(\"\\n\");\n"
"			printf(\"%-10s %-10.6f \\n\", \"intra: \",  partial_intraE[0]);\n"
"			printf(\"%-10s %-10.6f \\n\", \"grids: \",  partial_interE[0]);\n"
"			printf(\"%-10s %-10.6f \\n\", \"Energy: \", (partial_intraE[0] + partial_interE[0]));\n"
"			#endif\n"
"\n"
"			#if defined (PRINT_ADADELTA_GENES_AND_GRADS)\n"
"			for(int i = 0; i < dockpars_num_of_genes; i++) {\n"
"				if (i == 0) {\n"
"					printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"					printf(\"%13s %13s %5s %15s %15s\\n\", \"gene_id\", \"gene.value\", \"|\", \"gene.grad\", \"(autodockdevpy units)\");\n"
"				}\n"
"				printf(\"%13u %13.6f %5s %15.6f %15.6f\\n\", i, genotype[i], \"|\", gradient[i], (i<3)? (gradient[i]/dockpars_grid_spacing):(gradient[i]*180.0f/PI_FLOAT));\n"
"			}\n"
"			#endif\n"
"\n"
"			#if defined (PRINT_ADADELTA_ATOMIC_COORDS)\n"
"			for(int i = 0; i < dockpars_num_of_atoms; i++) {\n"
"				if (i == 0) {\n"
"					printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"					printf(\"%s\\n\", \"Coordinates calculated by calcenergy.cl\");\n"
"					printf(\"%12s %12s %12s %12s\\n\", \"atom_id\", \"coords.x\", \"coords.y\", \"coords.z\");\n"
"				}\n"
"				printf(\"%12u %12.6f %12.6f %12.6f\\n\", i, calc_coords_x[i], calc_coords_y[i], calc_coords_z[i]);\n"
"			}\n"
"			printf(\"\\n\");\n"
"			#endif\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		#endif // DEBUG_ENERGY_ADADELTA\n"
"\n"
"		for( int i = tidx;\n"
"		         i < dockpars_num_of_genes;\n"
"		         i+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			if (energy < best_energy) // we need to be careful not to change best_energy until we had a chance to update the whole array\n"
"				best_genotype[i] = genotype[i];\n"
"\n"
"			// Accummulating gradient^2 (eq.8 in the paper)\n"
"			// square_gradient corresponds to E[g^2]\n"
"			square_gradient[i] *= RHO;\n"
"			square_gradient[i] += (1.0f - RHO) * gradient[i] * gradient[i];\n"
"\n"
"			// Computing update (eq.9 in the paper)\n"
"			delta[i] = -1.0f * gradient[i] * native_sqrt(native_divide((float)(square_delta[i] + EPSILON), (float)(square_gradient[i] + EPSILON)));\n"
"\n"
"			// Accummulating update^2\n"
"			// square_delta corresponds to E[dx^2]\n"
"			square_delta[i] *= RHO;\n"
"			square_delta[i] += (1.0f - RHO) * delta[i] * delta [i];\n"
"\n"
"			// Applying update\n"
"			genotype[i] += delta[i];\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		#if defined (DEBUG_SQDELTA_ADADELTA)\n"
"		if (/*(get_group_id(0) == 0) &&*/ (tidx == 0)) {\n"
"			for(int i = 0; i < dockpars_num_of_genes; i++) {\n"
"				if (i == 0) {\n"
"					printf(\"\\n%s\\n\", \"----------------------------------------------------------\");\n"
"					printf(\"%13s %20s %15s %15s %15s\\n\", \"gene\", \"sq_grad\", \"delta\", \"sq_delta\", \"new.genotype\");\n"
"				}\n"
"				printf(\"%13u %20.6f %15.6f %15.6f %15.6f\\n\", i, square_gradient[i], delta[i], square_delta[i], genotype[i]);\n"
"			}\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		#endif\n"
"\n"
"		// Updating number of ADADELTA iterations (energy evaluations)\n"
"		if (tidx == 0) {\n"
"			if (energy < best_energy)\n"
"			{\n"
"				best_energy = energy;\n"
"#ifdef ADADELTA_AUTOSTOP\n"
"				cons_succ++;\n"
"				cons_fail = 0;\n"
"#endif\n"
"			}\n"
"#ifdef ADADELTA_AUTOSTOP\n"
"			else\n"
"			{\n"
"				cons_succ = 0;\n"
"				cons_fail++;\n"
"			}\n"
"#endif\n"
"\n"
"			iteration_cnt = iteration_cnt + 1;\n"
"\n"
"			#if defined (DEBUG_ADADELTA_MINIMIZER) || defined (PRINT_ADADELTA_MINIMIZER_ENERGY_EVOLUTION)\n"
"			printf(\"%20s %10.6f\\n\", \"new.energy: \", energy);\n"
"			#endif\n"
"\n"
"			#if defined (DEBUG_ENERGY_ADADELTA)\n"
"			printf(\"%-18s [%-5s]---{%-5s}   [%-10.7f]---{%-10.7f}\\n\", \"-ENERGY-KERNEL7-\", \"GRIDS\", \"INTRA\", partial_interE[0], partial_intraE[0]);\n"
"			#endif\n"
"#ifdef ADADELTA_AUTOSTOP\n"
"			if (cons_succ >= 4)\n"
"			{\n"
"				varrho *= LS_EXP_FACTOR;\n"
"				cons_succ = 0;\n"
"			}\n"
"			else\n"
"				if (cons_fail >= 4)\n"
"				{\n"
"					varrho *= LS_CONT_FACTOR;\n"
"					cons_fail = 0;\n"
"				}\n"
"#endif\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE); // making sure that iteration_cnt is up-to-date\n"
"#ifdef ADADELTA_AUTOSTOP\n"
"	} while ((iteration_cnt < dockpars_max_num_of_iters)  && (varrho > 0.01f));\n"
"#else\n"
"	} while (iteration_cnt < dockpars_max_num_of_iters);\n"
"#endif\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"	// -----------------------------------------------------------------------------\n"
"\n"
"	// Mapping torsion angles\n"
"	for ( int gene_counter = tidx+3;\n"
"	          gene_counter < dockpars_num_of_genes;\n"
"	          gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		map_angle(&(best_genotype[gene_counter]));\n"
"	}\n"
"\n"
"	// Updating old offspring in population\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	event_t ev2 = async_work_group_copy(dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"	                                    best_genotype,\n"
"	                                    dockpars_num_of_genes, 0);\n"
"	// Updating eval counter and energy\n"
"	if (tidx == 0) {\n"
"		dockpars_evals_of_new_entities[run_id*dockpars_pop_size+entity_id] += iteration_cnt;\n"
"		dockpars_energies_next[run_id*dockpars_pop_size+entity_id] = best_energy;\n"
"		#if defined (DEBUG_ADADELTA_MINIMIZER) || defined (PRINT_ADADELTA_MINIMIZER_ENERGY_EVOLUTION)\n"
"		printf(\"\\n\");\n"
"		printf(\"Termination criteria: ( #adadelta-iters >= %-3u )\\n\", dockpars_max_num_of_iters);\n"
"		printf(\"-------> End of ADADELTA minimization cycle, num of energy evals: %u, final energy: %.6f\\n\", iteration_cnt, best_energy);\n"
"		#endif\n"
"	}\n"
"\n"
"	// Asynchronous copy should be finished by here\n"
"	wait_group_events(1, &ev2);\n"
"}\n"
;
#endif // End of STRINGIFY_H
